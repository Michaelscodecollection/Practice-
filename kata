

const hello = s =>
  `Hello, ${s ? (s[0].toUpperCase() + s.slice(1).toLowerCase()) : 'World'}!`;
// so here we have our one liner
// we start of by creating our function using ES6 notation. we wrap the enture return in a 
// back tick. we write our Hello. this consolidates the code since both expected returns
//  contain a greeting. the response after hello is what differs. so we use a ternary
// operator from there. we use our dollar sign and curly braces so as to allow the return 
//  statement ot be at variable to whatever is recieved. if s is accounted for, meaning it exists
//  we grab the 0 index, capitalize it with our toUpperCase method/ using dot notation
// and we slice from the 1 index onward and we lowercase it. the result would be 'hello
// Name.' if there is no name meaning their is no input accounted for, we return a simple
// 'hello world.' main methods are toUpperCase- uppercases whatever this method is set and 
// attached to. slice- which  slice() selects the elements starting at the given start argument, 
// and ends at, but does not include, the given end argument. so we sliced from the 1 index onward and used toLowerCase to 
// allow for our return to meet basic grammer requirments. 
  
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function roundIt(n){
  var [a, b] = n.toString().split('.');
  return a.length > b.length ? Math.floor(n) : a.length === b.length ? Math.round(n) : Math.ceil(n);
  return Math.Floor if n is true(true), if false test to see if a and b are equal(false but true), if true return Math.round if it is still false, return Math.ceil.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function solution(a, b) {
  return a.length < b.length ? a + b + a : b + a + b
}
// so frustatingly enough, this solution once again was way easier than I was making it out to be. here we used an effecient ternary operator. if a < b we return a + b + a : if
that is not the case, we use b + a + b. thats it. im not sure if a & b get split automatically in half. my first approach was to split the shorter one but you can only really do that with
an array and thats not what we started with, so trying to make that happen was going to over complicate it for sure,. 
function getDrinkByProfession(param) {
  param = param.toLowerCase();
  
  switch(param) {
    case "jabroni": return "Patron Tequila";
    case "school counselor": return "Anything with Alcohol";
    case "programmer": return "Hipster Craft Beer";
    case "bike gang member": return "Moonshine";
    case "politician": return  "Your tax dollars";
    case "rapper": return "Cristal";
    default: return "Beer";
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function checkExam(array1, array2) {
 // store points in variable (+=, -=)
  //we will need a for loop 
  // compare arrays. if array1[i] === array2[i] add 4
  // if array1[i] !== array2[i] subtract 1 
  // if no answer, add zero
  //if points < 0 return 0.
  //["a", "a", "b", "b"], ["a", "c", "b", "d"]
  let points = 0;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
  // here we create our for loop. now we know we are dealing with two arrays and we are comparing the both of them with one another. since we have the same length this will require
  one for loop. we will be comparing them side by side. if both answers are equal '===' we want score += 4. if the answer is incorrect we want score -= 1. if no answer is provided
  we want score += 0. 
  in our final return we want to check if score is < 0. if the final score is < 0, we will set the score = to 0 as you cannot have a negative score in this scenerio. 
  for (let i=0; i<array1.length; i++){
    if (array1[i] === array2[i]){
      points += 4;
    }else if (array2[i] === ''){
      points += 0;
    }else{
      points -= 1;
    }
  }
  return points < 0 ?  points = 0: points
  
 // if (points < 0){ 
   // points = 0;
 // }
  //return points
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
const checkExam = (array1, array2) => {
  let result = array2.reduce(
//     reduce syntac calls for (previous value, current value, current index)
//     previous value in this case is the cumulative score. answer is the current value we are
//     // measuring. i stands for the current index. these are all in respect to array2.
    //if the answer of array2(the current value) == array1[i] score(previous value increases by 4)
    // score represents the cummulative result of the reduce method so far.(previous)
//     answer represents the current value being measures/compared. 
    //i represents the index value being measured. 
    (score, answer, i) => {
      if(answer == array1[i]) return score += 4;
      else if(answer == 0) return score += 0;
      else return score - 1;
    }
    
    
  , 0);
  return result < 0 ? 0 : result;
  
  }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const greet = (name, owner) => {
return name === owner ? 'Hello boss' : 'Hello guest' 
}
// I got the equation and function right. I just need to remember to return.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')
// here we are using regex, a syntax I am completeley unfamiliar with but am excited to dive into
// we have our es6 function notation that leads to our implementation. 
// from left to right we have s(string).replace(variable to be reolaced, replacement variable)
// or in this case s.replace(/0/g,O).  here we ourline that we are targetting /0/ and that we are 
// targetting 0 globably with (g) meaning we are targetting every representation of this.
// and we want to replace this with '0'. we tak on replace after each replace because these are all an
// extention/ method to be used on the s(our string). I need to be more curious about the methods at my disposal. I need to get creative in searching for these methods
// so we have correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function paperwork(n, m) {
  return n < 0 || m < 0 ? 0 : n * m
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const century = year => Math.ceil(year/100)
// we input a 4 digit number that must return as a two digit number. we know that 
// to get the century, our year must be rounded up i.e 1700 is the 18th century.
//  so we know we are going to use a Math.ceil, this will round up whatever our output is. 
// we then divide the year by 100 to give us a two difit number. 1705 turns into 17.05, which then
// turns into 18 when the Math.ceil method is used. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//so here we are converting from american floor units to european floor units. we know that european units start at 1 whereas american united start at 0. 13 does not exist so
//starting here, we know that the difference between the two moves from 1 to 2.
//so before 13 if e < 13 we return n-1
//if greater than 13 we return n-2. but it has to start greater than 0 otherwise we get a negative number. 
//so if n < 0 (starting at 1) we use n-1. if n >= 13 we move to n-2. 

const getRealFloor = n => {
  if(n >= 13) return n - 2
  if(n > 0) return n - 1
  return n
}

or

here we use a ternary operator. if n > 13 is true, we return n-2. if it is false but n > 0 is true, we return n-1. if thats false we just return n 
function getRealFloor(n) {
  return n > 13 ? n - 2 : n > 0 ? n - 1 : n;
}
//so the way we nest ternary operators is we place the next function in the false placment and continue --> argument trueValue : falseButTry ? true : stillfalseButtry ? true : finalIfFalse. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function testEven(n) {
  return n % 2 === 0 ? true : false;
}
//I need to remember that there are all the answers I want and finding most methods are intuitive. figure out what i need to do, articulate what method that could be or terminologies that would
//fit into a method type, search. every answer I need is there and often times its less work to look for the method than it is to build code from scratch. Im wasting too much time
// trying to build codes and functions when there are methods out there that people have built to save me time. to ignore this is to hold myself back. I need to take this seriously. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function expressionMatter(a, b, c) {
//we are looking for the largest number available. we have a list of arguments that we want to pass through. at the end of the execution we want the computer to return to us
// the largets number. we use Math.max, which has the syntax Math.max(value1, value2, value3) or in other words Math.Max|imum value of|( equation1, equation2, equation3). 
//so as follows we break it down.
  return Math.max(
  // we are asking the computer to return the maxiumum value out of the following equations
    a + b + c,
    a * b * c,
    a * (b + c),
    (a + b) * c,
    a + b * c,
    a * b + c,
  );
}
when i hear something along the lines of  return the largest number, I need to think about Math.max as my first train of thought. I didnt realize I could use equations in the syntax
//looking back it makes sense this would be a fucntional use of the method. I need to remind myself that each method is more powerful and versatile than my insticnts say. im still
//over complicating things. there are simple solutions. if i had typed in return largest value, there is no doubt Math.max would have been my first option. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function squareArea(A){
  // so we are need to break this down. if we find the cirumfrence of the circle, we will
  // be able to find the diameter of the square because the diameter will be equal to the 
  // circles radius. once we find the radius we simpily pass it thorugh an equation to find the 
  // area of a square. we use Math.round to round to nearest two decimals.
  var circum = 4 * A;
  var radius = circum / (2 * Math.PI);
  var area = Math.pow(radius, 2);
  return Math.round(area*100)/100
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//class SmallestIntegerFinder {
  findSmallestInt(args) {
    // we use the spread operatir so that the computer seperates the values of the array to be 
    //compared instead of treating the whole array as a single value. we use spread
    //operators when we are dealing with array lists for that reason. 
    return Math.min(...args)
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
usdcny = $ => `${($ * 6.75).toFixed(2)} Chinese Yuan`;

//this was a super clever appraoch. I liked how they used the dollar sign as the value placeholder being inputted. I did everyhting right up until the toFixed method, which ultimatley ended
//up being a relaly cool tool once I did some research. basically it just fixes the amount of decimal places being returned. we create our input variable, use back tics to return the
//final value in a string with text. thats about it

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twiceAsOld(dadYearsOld, sonYearsOld) {
  let twiceValue = sonYearsOld * 2;
  //lets say the dad is 40 and the son is 13. the father was twice as old as the son at 26
//   so we return dads age - twice value to get the years ago. if we go in the negative then we know
  //that we have to add years, so we instead return twiceValue-dadYearsOld to get the amount of years until
  return dadYearsOld - twiceValue >= 0 ? dadYearsOld - twiceValue : twiceValue - dadYearsOld;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function updateLight(current) {
  
  return current === 'yellow' ? 'red' : current === 'green' ? 'yellow' : 'green';

}

const reverseSeq = n => {
let arr = [];
  for (let i=n; i>0; i--) {
  //we start at n and we work our way down after each iteration. 
    arr.push(i);
    } return arr;
};

// so here I did everything right except for the syntax of my for loop. I wasnt thinking. I need to look at each individual mechanism im coding. Im not paying attention. 
// so in this case I actually tried to make it simpiler than it was. although im pleased i searched for a possible solution, the switch case was an obvious solution that I should have
// approached and then refactored. I think what I need to do is approach the longer versions and THEN refactor instead of just trying to refactor. 
// if im dealing with values and a string like this i need to think of more creative solutions. I need to ask myself what do my available resources fit into
function basicOp(operation, value1, value2) {
    switch (operation) {
        case '+':
            return value1 + value2;
        case '-':
            return value1 - value2;
        case '*':
            return value1 * value2;
        case '/':
            return value1 / value2;
        default:
            return 0;
    }
}

function digitize(n) {
  return String(n).split('').map(Number).reverse()
}

// so my first inclenation was to split and reverse. while that was correct, I forgot one thing. you cant split integers. I need to convert to a string, split, map out that string as Numbers,THEN 
//I reverse it. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
var summation = function (num) {
  let result = 0;
  for (var i = 1; i <= num; i++) {
  //we start i at 1 because it is only being returned as a positive number and we are only including numbers <= 1. we then make i<=num so that num is included in the final addition. 
  
    result += i;
  }
  
  return result;
}
// I had all the right instincts. I did two things wrong. I didnt set the function right which may have been why I kept getting 0/ NAN, I set I to 0 and num. I knew that it was going to be 
// a different type of for loop, and I was paying attention to that this time, which is encouraging. And I made i < num instead of <= num, which makes sense because we wanted to
//include the last number in the addition too. I also kept trying to return num[i] which isnt the value of the index im targeting, its the index number. If i want the value of whatever
iteration im on, i simp[ily need to type i
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function numberToString(num) {
  return num.toString()
}
 
 function boolToWord( bool ){
 return bool ? 'Yes' : 'No';
}

const opposite=(number)=> {
  return number < 0 ? Math.abs(number) : -number;
}

function even_or_odd(number) {
  return number % 2 === 0 ? 'Even' : 'Odd';
}
const otherAngle = (a, b) => {
  // All angles of a traingle will add up to 180. 
  // return 180 - (a + b)
  
  return 180 - (a+b);
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const doubleChar = (str) => str.split("").map(c => c + c).join("");
//so we want to repeat a string. my first instinct of split and join were correct, I was just missing how to connect the two in this context. so we split, which turns it into an array
// beause its an array and we are able to use the map method to make copies of what we already have available. we basically say that we want to take c => and make two c's. 
//once we that function executes and we have two of every iteration (naturally dont by the map method) we then join it('') with no space in the middle.

const digitize = (n) => { return String(n).split('').map(Number).reverse() }
//so in this case i didnt realize that the split method only works with strings. so before i can split i have to make it a string with the String method. cool. once
// I its a String and split, I map out what was split with maps argument (the parameters given to the computer to determine how to map out the data) being the Number method, which will 
//turn the string into numbers. now that we have our numbers split up in an array, we use the reverse method to flip and we return the final product.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
  return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
  // so here we are using a spread operator and new operator to create a new array which will be set using the inputted arr that will only return unique elements. that is only one
  //of each instead of all of them. if there are 2,2,2,5,5,9,2,10 the new array will return as 2,5,9,10. we the sort the new array with a function(a,b)=>b-a returning the largest numbers
  //first using basic sorting syntax. we then slice from 0,2 (the first and second items) and return.
}
// while i didnt get this one, im super stoked because i basically touched on every element the solution had, which is encouraging to say the least. I played with sort, slice, created a a,b equation
.i neew to figure out what ...new and Set is. Im assuming ...new creates a new array
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
var stringToNumber = function(str){
  // put your code here
  return Number(str);
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function abbrevName(name){
let nameArr = name.split(' ')
return (nameArr[0][0] + '.' + nameArr[1][0]).toUpperCase();
}

function twoHighest(arr) {
  return [...new Set(arr)].sort((a,b)=> b-a).slice(0,2)
}
// function twoHighest(arr) {
//   return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
// }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const trueFalse = (b) => return b ? 'true' : 'false'
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function invert(array) {
  var newArr = [];
  for(var i = 0; i < array.length; i++){
    newArr.push(-array[i]);
  }
   return newArr;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const positiveSum =(arr)=>{
  let count=0
  for (let i=0; i< arr.length; i++){
    if(arr[i] > 0)
      count += arr[i];
  }
  return count;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function positiveSum (arr) {
  return arr.filter(x => x>=0).reduce((a, c) => a + c, 0);
}


const positiveSum =(arr)=>{
 return arr.reduce((cumm,curr)=>cumm + (curr > 0 ? curr : 0),0);
//   with a reduce funtion, if we want to get the sum of an array, we need to clarify to
  //computer that we want it to start at the zero index because without an initial value
  //provided, it starts at the 1 index.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function enough(cap, on, wait) {
 return wait <= (cap -on) ? 0 : Math.abs((cap-on)-wait)
  
  
}
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function sumStr(a,b) {
  let summ = Number(a) + Number(b) 
  return String(summ)
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function isDivisible(n, x, y) {
  return n % x === 0 && n % y === 0 ? true : false;
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function remainder(a, b){
  return a > b ? a % b : b % a
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function enough(cap, on, wait) {
 return wait <= (cap -on) ? 0 : Math.abs((cap-on)-wait)
  
  
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

class Kata {
  static getVolumeOfCuboid(length, width, height) {
    return length * width * height
  }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function betterThanAverage(classPoints, yourPoints) {
  return yourPoints > (classPoints.reduce((a,b)=>a+b)/classPoints.length) ? true : false;
}

function switchItUp(number){
  switch(number) {
    case 0:
      return 'Zero';
    case 1:
      return 'One';
    case 2:
      return 'Two';
    case 3:
      return 'Three';
    case 4:
      return  'Four';
    case 5:
      return 'Five';
    case 6:
      return 'Six';
    case 7:
      return 'Seven';
    case 8:
      return 'Eight';
    case 9:
      return 'Nine';
    default:
      return 'Unknown number';
  }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function invert(array) {
   return array.map( x => x === 0 ? x : -x);
}

//okay, so I had the right assumption of mapping but i didnt follow that hunch. mapping seems to be a function I need to get more comfortable using. I need to remember that mapping is such
// a great tool for whenever I want to use for loop functionality while also applying a function into the contents. Here We return a mapped array with rach iteration (x) going through
// a function that tests if x === 0. if x does not deeply equal 0

function areYouPlayingBanjo(name) {
 return name[0] === 'R' || name[0] === 'r' ? `${name} plays banjo` : `${name} does not play banjo`

}
function maps(x){
return x.map(x => x * 2)
}
const zeroFuel = (distanceToPump, mpg, fuelLeft) => {
  return distanceToPump - (fuelLeft * mpg) <= 0 ? true : false
};

const areaOrPerimeter = function(l , w) {
  return l === w ? l * w : 2 * (l+w);
};

  //so I tried  to use a spread operator which may have worked but was a lot more complicated.
  // I was on the right track with everything else but had a couple syntax issues.
  // here we split the array, sort, target the -1 index which is the last characted in each
  //individual string and we create our function for sorting with a > b. I didnt realize this 
  //before but when sorting by numbers we use the equation (a -/+ b) but when we sort letters we
  //have to use (a >/< b). so again I was on the right track. I tried targeting the index 
  //but again, that wasnt going to work the way that I had hoped. instead I should have used
  //a.slice(-1) which would target the end/ final character in each iteration.
  const last = ( $ ) => $.split(' ').sort((a,b)=> a.slice(-1) > b.slice(-1))
}


const numbers = (...arr) => arr.every(x => typeof x === 'number')

//so here we say that whatever arr is will be spread as it passes into the function. 
// we then attach a every method to arr to check if every iteration of the arr matches.
// in every() we pass a function that will check if the typeof x is = to number. 
//every has a call back that will naturally return true or false.

discovered a cool method called every(which checks if iteration of a delivered array matches a the parameter defined by a function in the callback)


function square(n){
return Math.pow(2, n-1)
//so we basically just want to pass through the returned value of the inputted number - 1 
  //and them doubled.
}

function spongeMeme(sentence) {
return sentence.split('').map((v,i) => i % 2 ? v.toLowerCase(): v.toUpperCase()).join('');
} 
//super stoked. even though i didnt get it and ignored by gut, my hunch was completeley correct. Im growing the intuition. Here we split the sentence. because we want to deal with each
//iteration (which basically means we need a for loop) we use a map and pass a function in map to tell the computer how we want to treat each iteration (DANK!). we then pass through our parameters.
//which is a function. I forgot the syntax for map. we have v,i . v standing for the current element and i so that we can target the elements index. we target the index with i % 2 === 0
// if true we manipulate the element. so were dealing with the element AND the index. luckily for us map has it built in to distinguish the two. I have to remember that moving forward because I
//almost had it. 

// ficing code const findLongest = (str)=>{
  
  var spl = str.split(" ");
  var longest = 0
  
  for (var i = 0; i < spl.length; i++){
    if (spl[i].length > longest) {
      longest = spl[i].length
    }
    }
    return longest
}

function gooseFilter (birds) {
  var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
  return birds.filter(b => !geese.includes(b));
};

okay so on this one, I actually had the logic right but i mixed up the syntax. in my return i did return birds.filter(bird => bird.includes(...geese)), looking back, I realize
// this makes sense btecause i used the input, and then searched the the input to see if it would include the geese array. !gees.includes(b) is really asking the computer
// if the array geese includes b. if it does not, meaning we get a return value of true, we filter it out. i also wasnt paying attention to what the problem was really asking. 
I thought the point was to only keep the defined birds when in reality I was supposed to filter our the defined birds. Im happy because my logic was almost correct in that case.
// just to be clear, the filter method creates a new array filled with true values and removes false values. the includes method is a true/false method. which is exactly what we needed
//for the filter. this is also why we had to use a ! because we were only wanting to keep the values !included in our geese array.
//if b is not included in geese, then we keep the value.

function hoopCount (n) {
return n >= 10 ? "Great, now move on to tricks" : "Keep at it until you get it"
}

function findDifference(a, b) {
let A = a.reduce((acc,curr)=>acc * curr);
let B = b.reduce((acc,curr)=> acc * curr);
  return A - B >= 0 ? A-B : B-A;
}

function DNAtoRNA(dna){
  return dna.replace(/T/g, 'U');
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function find_average(array) {
  var sum = array.reduce((a, b) => a + b, 0);
  return sum/array.length;
}
we want to return 0 if the array is empty, so we start at the 0 index and we do a + b. If its 0 our last return will be 0 / 0 so we are successful


-----------------------------------------------------------------reviewing past katas now-------------------------------------------------------------------------------
const maps=(x)=>{
return x.map(x=>x * 2)
}
const areYouPlayingBanjo = (name) => {
  return name[0] === 'r' || name[0] === 'R' ? `${name} plays banjo` : `${name} does not play banjo`;
}
const numbers = (...arr) => arr.every(x => typeof x === 'number')
this one i actually almosty got perfectly but i forgot about the every method. stoaked because last time i didnt even get close

const areaOrPerimeter = function(l , w) {
 return l === w ? l * w : 2 * (l + w)
};

const animal=(obj)=>{
  return `This ${obj.color} ${obj.name} has ${obj.legs} legs.`
}

function countPositivesSumNegatives(input) {
  //so here i really like this code because it basically follows verbatim the instructions.
  //its objective based code. 
    if (input == null || input.length == 0)
      return [];
    // we begin with our basic parameters. if the input is null or the length of input is 0
  // we return an empty array.
    var positive = 0;
    var negative = 0;
    // we know we are looking for a count, so we create our count storage for positive and negative numbers
  
    for (var i=0, l=input.length; i<l; ++i)
    {
      if (input[i] > 0)
        ++ positive;
        //I also was not paying attention to the instructions. I keep doing this. I need to focus on what is being asked of me, I need to get back into the habit of pseudo coding
        // im working with fundamentals and so I think im tough shit because of all of these one liners. Im not. Just because I know what to do and am excited doesnt mean i shouldnt take the time to processs what is 
        //in front of me. 
      else
        negative += input[i];
    }
  //we use a basic for loop to organize which index will be sorted to which sum. 
    
    return [positive, negative];
  // we place our counted values into an array and we return. 

//okay i need to get better at deconstructing. im trying to be fancy and its not smart. I could have solved this one if i wasnt always trying to do one liners. I need to be more
// aware of the fact that i need to learn to write good code. not impressive code. clean code. 
function calculator(a,b,sign){
 if ((typeof a == 'number') && (typeof b == 'number')){
   switch(sign){
       case '*':
       return a * b;
       break;
       case '+':
       return a + b;
       break;
       case '/':
       return a / b;
       break;
       case '-':
       return a - b;
       break;
   }
  
 }
 return 'unknown value'
}
// I need to slow down and think of all the tactics i can approach problems with. I once again, thought i could just type out what was in my head and totally over complicated the code.
switch statment would have been such an easy approach. at this point im being lazy and i know it. I need to be intentional, focued, and give the problem the respect it deserves.
coding requires attention and focus. I cant just superfically think my way through this career. 

function between(a, b) {
  //  we want to input 1 and 4 and get a returned value of 1,2,3,4.
  //how can i go about doing this? 
  //i can use a for loop. start i at 8, and make the iteration go until it is <= b.
  // 
  let arr = [];
  for(let i=a; i <= b; i++){
    arr.push(i)
  }
    return arr;
  
}
function getAge(inputString){
return parseInt(inputString)
}

function pipeFix(numbers){
  var first = numbers[0];
  var last = numbers[numbers.length-1];
  // so here we create our first (starting point) and out last (ending point)
  // we use the 0 index to locate our starting value and the -1 index to input our ending value.
  var arr = [];
  // we create an array to harness our final result
  for(var i = first; i <= last; i++) {
  // we then use our first and last values in a for loop and we increment through. we push the output of the for loop into our new array.
    arr.push(i);
  }
  return arr;
}
//so we create our starting and ending point. then we just for loop from start to finish. I tried creating and replacing all the values which was way more work. I need to spend more time thinking 
about what i need to do. Maybe i should start a timer. take one minute to not code at all and just think of my various approaches instead of just jumping on the first thing that makes sense. 

function cost (mins) { 
  return 30 + ( mins>65 ?  Math.ceil((mins-65)/30) : 0 )*10
  // return 30 + if minutes is greater than 65 min ($30 for the first hour + 5 min grace period)
  // then we do round up using Math.ceil. we do mins - 65/30. that number gets multiplied by 10
  // and then is added to the total cost. I need to be better about picking out details like round
  //up.
  
  function perimeterSequence(a,n) {
  return a * n * 4
 //over complicated it again. I need to slow down. I need to break down the problem even smaller then I am. there arent big chunks that im forgetting. 
}

//today is my first day moving onto 7 kyu and its been an adjustment 
first off, I have to get used to the fact the code is going to be much longer moving forward. no more one liners. so when writing out the code, I have to really set up the playing
//field im going to be working with. no more one liners. I need to write everything out and create all the variables im going to be working with. I also have to embrace the mantra
of ' the first step to knowing is not knowing. ' 
the last couple katas i did i made things a little more complicated than i needed too. I need to simplify but its not just that. I tried simplifying but my ignorance with different fundamentals
of algebra is effecting my ability to problem solve. I need to make an investment in my understanding of algebra. 
that being said, its time to break down the first big problem
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function add(num1, num2) {
// so here we get our two numbers. now first thing i need to note is that one of the things we need to check for is for which numbver is greater, because if theres two numbers for 
// one and theres three numbers for another, its gonna effect which number is being added to which number.

    num1 = num1.toString().split("").reverse().join("");
    num2 = num2.toString().split("").reverse().join("");
    //so here we create our variables num1 and num2 exceot we create them in the context of solving the problem.
    // we know that we need to turn the numbers into a string, split the number, reverse it, and join it back. this turns 200 into '002' and 60 into '06'

 

    if (num1.length < num2.length) {
        [num1, num2] = [num2, num1];
    }
// here we check for if num1.length is less than num2.length. 
in the case that num1 is less than num2, our [num1,num2] array will instead be [num2,num1].
 

    var returnString = "";
    here we have our returning value which is going to be a string at first.
    
    for (var i = 0; i < num1.length; i++) {
    // since we made the largest value num1, we are going to use a for loop to loop through these values. this is why we made our number a string.
    
        var int1 = parseInt(num1[i]);
      // now we are going to turn our string into a number. int1 is going to be representing num1 iterations and int2 will be representing num2 iterations. 
      
        var int2 = parseInt(num2[i] || 0);
      
        returnString = (int1+ int2).toString()+returnString;
        // now that we have the two integers defined as to being which ever num[i] we are on, we can loop through.
        // we have int1 + int 2 turned into a string and placed next to which ever value was last created. 
        so if we have 268 + 318 --> '862' + '813' --> 
        8 + 8 === 16 --> returnString == '16'
        6 + 1 === 7 --> returnString =='716'
        3 + 2 === 5 --> returnString == '5716'
        
    }
    
    return parseInt(returnString);
    //here we turn our '5716' into 5716 (String to Integer)
}
// my main mistake was not breaking it down more. I can make my life a lot more simple if I take the time to make create a map to my destination. 

function arrowArea(a,b) {
  // A = bh/2
  //b = a
  //h = b/2
  let base = a;
  let h = b/2;
  return (base * h)/ 2
}
// followed my own advise for an A1 result

// we want to scan the string given to us.
  //we are looking specifically for 'n'
  //if 'n' count <= 15 return 'Woohoo' else return 'Car Dead'
  //I can use a count variable. if x[i] == n count += 1. if count = 16 return car dead
  let count = 0
  for (let i=0; i < x.length; i++){
    if (x[i] === 'n'){
      count += 1;
    }
    
  }
  return count > 15 ? 'Car Dead':'Woohoo!'
}

//really slowed myself down and let go of the pressure to solve it and wow it was so much easier. My mentality has been all wrong. I need to break it down, get curious, get analytical,
and just take it piece by piece. Its not one big problem that needs to be solved. Its a bunch of little ones. I should get better with using console.log()


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function automorphic(n){
  let len = n.toString().length
  //here we create out number and measure its length. this value will be used to grab the particular index we want
  let num = (n * n).toString().slice(-len)
  we then create our squared value, turn it into a string and we slice the index using a negative number (which starts from the end of the array and will go until the value
  len is achieved.
  return (n == num) ? 'Automorphic' : 'Not!!'
  //we then use a double equal sign to check if the values are the same (although not deeply same since num is a string and n is a integer. 
}

function balancedNum(number) {
  let numstr = number.toString();
  let leftside = "";
  let rightside = "";
  if (numstr.length/2 < 1 || numstr.length === 2) { 
    return "Balanced";
  }
  
  function createArrayOfTiers(num) {
    let prev = '';
    return [...num + ''].map((value) => {
        return prev += value;
    });
}
  if (numstr.length % 2 === 0) {
    leftside = numstr.slice(0,numstr.length/2-1);
  } else {
    leftside = numstr.slice(0,numstr.length/2);
  }
  rightside = numstr.slice(numstr.length/2+1);
  
  let lefttotal = leftside.split("").reduce((a,b)=>parseInt(a)+parseInt(b));
  let righttotal = rightside.split("").reduce((a,b)=>parseInt(a)+parseInt(b));
  return (lefttotal === righttotal) ? "Balanced" : "Not Balanced";
}

------------------------------------------------------------------------------------------------------------------------------------
const bump=x=>x.split('n').length>16?"Car Dead":"Woohoo!"
//so the split method is exactly what I was looking for when I was psuedo code. I knew that an optimal approach would be to cut out the 'n' and measure the length of that value.
//Its pretty simple, we use x.split('n') which basically seperates everything from 'n'we then use.length to measure the x value which now only has its 'n' value. after that its just a 
//basic ternary operator


function add(num1, num2) {
// first im going to turn the number into a string, split, reverse, and join.
  //im going to do this so that when im adding the values in the end, it goes in order.
  // im then going to make a conditional statment that will place the longest value 
  //in the variable num1. this is for when im adding so that the correct amount of numbers get 
  //looped through in the for loop.
  //now I will create my String Container, which will hold the value of the final intger vallue
  //after that I will make my for loop. this for loop with go for the length of num1 
  //I will make int1 and int2, which will create the number values of the new reversed string. 
  // now that the numbers have been flipped and made into an integer, I can add them. 
  // I add int1[i] to int2[i] || 0 if there is not value. these are made into strings so that they are
  //not added with each other but placed next to each other.
  // now that i have the final string and the numbers have been placed next to each other, I can 
  //return with a parseInt to make it into its final value
  num1 = num1.toString().split('').reverse().join('')
  num2 = num2.toString().split('').reverse().join('')
  
  if(num1.length < num2.length){
     [num1, num2] = [num2, num1]
  }
  let returnString = ''
  for (let i=0;i<num1.length; i++){
    let int1 = parseInt(num1[i]);
    let int2 = parseInt(num2[i] || 0);
    
    returnString = (int1 + int2).toString() + returnString;
  }
  return parseInt(returnString);
}

function cake(x, y){
//x is going to be the value of the total amount of candles we have
//y is going to be value of the candles that fall off,
//y is going to be a string of letters what we want to translate to their ACSLL values/ alphabitical position value
// even index will be targeted with ACLII values and odd with target their alphabitical position value. 
//if the total value attained for the candles that fell of is greater then 70%, the carpet will catch on fire. 
  let a = y.split("");
  //first we split y so that we can target each individaul letter and we place that array in the variable 'a'.
  let res = 0;
  // we create our result container which will hold the final value of the accumulated values.
  for (i in a){
  //we use a for in loop. i represents the index, and in a represents every variable that is in the array 'a'
    res += i % 2 == 0 ? a[i].charCodeAt(0) : a[i].charCodeAt(0) - 96;
    // now we want to add to our res variable. we do this with a += 
    // if i % 2 == 0, meaning its an even value, we want res to add its charcodeat value. if it is even we will take that value and subtract it by 96 to give us 
    // its alphabitical position value for the odd indexes. all these values will be added together for our final result.
  }
  return res > x * 0.7 ? 'Fire!': 'That was close!';
  //here we will use a ternery return statment. If res is greater than x(total candles) * 0.7 (70%) we will return 'Fire!' otherwise it will be 'The was close!'
}

function iceBrickVolume(radius, bottleLength, rimLength) {
  // variables at play:
  // radius- mid point of brick to bottle edge
  //bottleLength- total length of the bottle (height)
  // rim length - length from bottle top to brick.
  // what do I know? bottleLength - rimLength = brick height.
  //volume of the rectangle will be length times width times height
  let length = bottleLength - rimLength;
  let width = radius * 2;
  let height = width;
  return (length * width * height)/ 2;
 
}
const uniTotal = str => [...str].reduce((acc, char) => acc + char.charCodeAt(0), 0);
//this one is my favorite. while i will admite i forgot about th use of a spread operator, I did create a new array. when I was writing things out i decided to go with a manp 
//method, which would have worked, but I was missing the reduce method. encourging nonetheless. 


const uniTotal = ($) =>{
  //I want to take the string and split it.
  // I need a container for the values. 
  // im going to go through each value and translate it to its ASCII number using 
  //char
return [...$].reduce((acc, char) => acc + char.charCodeAt(0),0)
}


function repeatStr (n, s) {
  return s.repeat(n);
}

function remainder(a, b){
  return a > b ? a % b : b % a;
}

function countSheeps(arrayOfSheep) {
  
  // Im going to be searching an array, so that means a for loop/ map method is probably going to be
  // the best option. I need to iterate over each index. if that index is present, I need to add
  // it to my count. 
  // I could use a for loop, if statment, and count variable
  // I could also filter out the false values and then count the length of the remaining array.
  // I could probably map and use a count variable as well.
  //the cleanest option seems to be the filter method so Im going to pursue that. 
  // -------------------------------------------
  // filter strategy 
  return arrayOfSheep.filter(x => x === true).length 
}

const stringToNumber = (str) => {
  return parseInt(str)
}

const uniTotal = str => [...str].reduce((acc, char) => acc + char.charCodeAt(0), 0);
// okay so I was on the right track with this one. I used split instead of a spread operator. 
// what they did here was turn the str into a spread operator array. we then reduced that array. we only used the CharCodeAt(0)(0 standing for the 0 index) 
// acc does not need the charCodeAt method because its just the accumulation of tthe current indexs. each curr is translated to its ASCII value and then added to the accumnulated value
I was on the nose about using the reduce method and charCodeAt method. My execution lacked the spread operator. 

const areaOrPerimeter = function(l , w) {
  return l === w ? l * w : 2 * (l + w);
};

const getNames = (data) => {
  return data.map(x => x.name)
}
----------------------------------------------------------------------------------------------------------------------------------------------------------
function isCoprime(x, y){
    var factorsX = [];
    var factorsY = [];
    // I had the great instnct of creating arrays to push info in. and I thought up the same idea for the for loop being set to x. all super exciting. I feel like my brain is starting to 
    //see what it needs too. Im starting to trust my intuitions. at this point i just need to refine with trial and error. 
    var gcf = 1;
    // create a variable to contain the greatest common factor (for conditional reasoning.)
    for (var i = 2; i <= x; i++) {
    Here i create my for loop using x as my set loops and I set the starting point for the loop at 2 because I know 1 will be the GCF and im looking for all the numbers except for 1
    
        if (x % i === 0) {
        // here i set my first conditional. If x % the current iteration is === 0, im gonna push that number into out x array. 
        factorsX.push(i);
        }
    }
    for (var i = 2; i <= y; i++) {
    // here i set the next for loop, which is the same as before but for all of the y values. 
        if (y % i === 0) {
        factorsY.push(i);
        }
    }
    for (var i = 0; i < factorsX.length; i++) {
        for (var j = 0; j < factorsY.length; j++) {
        if (factorsX[i] === factorsY[j]) {
            gcf = factorsX[i];
            // now I create the for loop that will compare the two arrays. im gonna set this for loop = to factorsX.length
            //within that for loop we are going to have another for loop that will scan the factors for Y.length. 
            // if when searching the two for loops we find a common number, we are going to set gcf = to factorsX[i] or that particular iteration.        }
        }
    }
    if (gcf === 1) {
        return true;
    } else {
        return false;
    }
}


  //make it increment up to the highest number. I can push each iteration into an array.
  // after that I can reduce the array. 
  let arr = [];
  if(a > b){
  [a, b] = [b, a];
    }
  for (let i = a; i <= b; i++){
    arr.push(i)
  }
  return arr.reduce((a,b)=> a + b);
  
}
function getDecimal(n){
  // so im going to be given a number positive or negative. I need to take only the decimal
  //and return that decimal in the format of 0.decimal. 
  // my first instince is to split it at the decimal into two seperate variables while also.
  //making it a string. 
  // i will declare a variable that and place a string in that variable. the string will be '0.' 
  //once ive seperated i will take the integer representing the decimal and set the new string 
  //  newString = newSting + decimalNumber
  //then i will parseInt().
   let finalString = '0.'
   let [a,b] = n.toString().split('.')
  finalString = finalString + b;
return (parseFloat(finalString))
  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function cake(x, y){
// if the number of candles fallen is 70% of the total candles the carpet will catch on fire.
  // im going to get a string. I need to add up the string using ASCII values for even indexes 
  // and alphabitical position values for the odd indexes. 
  // if the carpet catches fire return ' fire ' , else return 'that was close!'
  // okay so I know im going to need charCodeAt() for odd values and charCodeAt()-96 for the
  //alphabitical position
  // x will be the total number of candles
  // x * 0.7 will equal 70% of the total amount of candles. 
  // im going to need to split y, and create conditionals based off of the value of each index number
  // if i % 2 === 0 return index[i] === charCodeAt()-96 else index[i] === charCodeAt()
  //for searching through I can use map or a for loop. 
  // after the values have been set, Im going to reduce the array.
  // I think I may have to create a new array and push the values in, but thatll be a little messy so
  // in an attempt to be cleaner, ill try to avoid this route starting off. 
  // I may be able to use a ternary operator in map. Ill start out with the for loop and 
  //remember this should I want to refactor after. 
  let fireHazard = x * 0.7;
  let even = [];
  let odd = [];
  for(let i=0; i<y.length; i++){
    if(i % 2 === 0){
      even.push(y[i].charCodeAt()-96);
      
    }else{
      odd.push(y[i].charCodeAt())
      }
    
  }
  let finalEven = even.reduce((acc,curr)=> acc + curr);
  let finalOdd = odd.reduce((acc,curr)=> acc + curr)
  let totalFallin = finalEven + finalOdd;
  return totalFallin > fireHazard ? 'Fire!' : 'That was close!';
  
}
function singleDigit(n) { 
  
  return n < 10 ? n : singleDigit([...n.toString(2)].reduce((a, b) => a + +b, 0)) 
}
//so here I was actually on the right track I just didnt order my variables correctly. I use a ternary operator to determine if n is a single digit. If n is, i return n. if it isnt
//im going to call the singleDigit function and inside that function im going to turn n into a array with a spread operator, make it binary with the toString(2), reduce

--------

function zombie_shootout(zombies, range, ammo) {
  const steps = range * 2;
  //so here i did not think about the total amount of steps. I forgot that range was 0.5 and that to get the total amount of steps for the for loop i qwou;d have to multiply by 2.
  // the for loop increments by 1, So if i wanted to for loop to go for the amount of steps being taken I would have to multiply by one to give the proper amount of time
  if (ammo < steps && zombies > ammo) {
    return `You shot ${ammo} zombies before being eaten: ran out of ammo.`;
    //basic if statement. here they addressed the numbers as they were inputted. Which makes more sense. I was coming at it from a wierd angle now that I think of it. 
    // I was trying to address the metrics as they changed which is way less effecinet. I also made it a race to 0. depending on which metric reached 0 first I would respond.
    //which honestly, what the hell was I thinking. Here they just took the logic presented to them, took the numbers presented to them, and wrote their code. they had a direct translation
    //while mine was abstract and wierd. while I like to be abstract in my approach to play more with the code I have, this was blatantly stupid. They didnt even use a for loop. 
   // like what the hell
  }
  
  if (zombies > steps) {
    return `You shot ${steps} zombies before being eaten: overwhelmed.`;
  }

  return `You shot all ${zombies} zombies.`;
}
I need to break the logic down more. try and see whats right in front of me.

function solution(A) {
  for (i = 1; i < 1000000; i++) {
    if(!A.includes(i)) return i;
  }
}

// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

const solution = (message, K) => {
    // limit = k
    // we want to splice, slice, or cut any digits that are not within
    //the length of K. 
    //it cant crop out part of a word. meaning- if the limit reaches
    //the length of k, that word will be taken out. so maybe if( not length ) split(' ') 
    // firstly, I should determine if the length is less then k.length 
    // because then I can just return the message. this is if else. 
    //so I know im going to need to check the length, scan the text to determine the length. if the length is greater than k, i can split the words into an array and pop until the length is less than k. once the length is less than k, I can join(' ') and return
    let textLength = message.length;

    if(textLength < K){
        return message;
    }else{
        let wordCount = message.split(' '),substr; 
        for(let i=wordCount.length;i>0;i--){
            wordCount.pop();
if(wordCount.join(' ').length < K){
    return wordCount.join(' ')
}
        }
    }
}

// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

//----------------------thought map to begin ----------------------

    // write your code in JavaScript (Node.js 8.9.4)
    // Start with N cars
    //There is a starting number of people and seats.
    // they are car pooling and they want to use as little cars as possible. 
    //so S are the total seats, P the total people.
    // we need to determine how many seats are to a car..
    //maybe we can sort the cars based on the cars with the most seats and
   // so P[i] and S[i] represent K[i](car).
   // so P[1] and S[4] represents 1 person driving a car with 4 seats.// P[2] S[4] represents two people driving in K car which has 4 cars
   // so im going to want to add up P.
   // then sort S from largest to smallest. 
   // let seats available
   //maybe I make a for loop that adds cars until S >= P
   // each index of S would represent the amount of cars being used. 
   // create carCount variable
   //  so if S >= P car
   //  carcount += 1
    // i may actually just have to sort the S from greatest to least.
    //do a for loop that += seating until it is >= people. 
    //so each iteration would add the current indexs S to a occupiedSeating variable, upon the next interation, I would check if >= P, if the next iteration begins, we add that to the car count.
    const solution = (P, S) => {
 let totalSeating = S.reduce((acc,curr)=> acc + curr);
 console.log(totalSeating)
 let totalPeople = P.reduce((acc,curr)=> acc + curr);
 let carPool = S.sort((a,b)=> b-a);
 console.log(carPool);
 let carCount = 0;
 let occupiedSeats = 0;
 for (let i=0; i<carPool.length; i++){
//okay. if occupiedSeats <= totalPeople we add carPool[i] to
//occupiedSeats and increase carCount += 1 for the iteration.
if (occupiedSeats <= totalPeople){
     occupiedSeats += carPool[i];
     carCount += 1;

 }
}
return carCount;
    }


function calc(x){
  let sum = n => [...n].reduce((a,b) => +a + +b);
  //here we create our sum paramaters. we make sum a function that takes n, creates an array with a spread operator, and we reduce all integers make it all integers positive
  
  let total1 = x.replace(/./g, x => x.charCodeAt(0));
  // we create our total1 value by replacing the string with their charCodeAt() values
  let total2 = total1.replace(/7/g,'1');
  // here we have our total2 value which we define as being total1 with our 7 replaced for 1
  return sum(total1) - sum(total2);
  we run both values through our sum function and return the difference
}

//I need to remember that anytime im dealing with an array, I can use regex and the replace function. I keep trying to make things complicated. 


function peak(arr) {
  let res = -1;
  
  for (let i = 0; i < arr.length; i++) {
  //so here we basically create a ternary. if the sums of both sides do not add up to the same we are just going to return our -1 value. 
  we create a for loop
    if (arr.slice(0, i).reduce((acc, cur) => acc + cur, 0) 
      === arr.slice(i + 1).reduce((acc, cur) => acc + cur, 0)) {
        res = i;
        // if the values from 0-i reduced === the values from slice(i + 1) (which startes slicing backwards) then we set res === to i
        
        //so we create our initial value for res, whihc is -1. we then go to create a for loop. in that for loop we will have an if statement. that if statment says that
        //if the begging index sum is === to the end index, we will set res = to that index. its very incremental. each sum is made for each iteration. (0-1, 0-2, 0-3) compared to
        // -1, -2, -3
    }
  }
  
  return res;
}


function getEvenNumbers(numbersArray){
  // filter out the odd numbers
  return numbersArray.filter(x => x % 2 === 0);
}

function wallpaper(l, w, h) {
    // width of rolls is 52 centimeters
  // length of the role is 10 meters
  // total length purchased must be 15% larger than length required
  // l w h is representing the room we are trying to fill.
  // I think i need to calculate the area of the room
  // then i need to divide the area by the rolls.
  // i need to multiply combined width by the hright
  let numbers = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve","thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"]
  
  let areaOfRoom = 2 * (l+w)*h;
  let wallpaperRoll = 0.52 * 10;
  let numberOfRolls = (areaOfRoom / wallpaperRoll);
  
  let totalRolls = Math.ceil(numberOfRolls * 1.15);
  
    return l = 0 ? 0 : (numbers[(totalRolls)])

  
}

function adjacentElementsProduct(array) {
// Okay so im looking for the greatest product of two numbers. 
  //these numbers have to be adjacent to each other
  // Im gonna need a for loop
  // im gonna multiply array[i] by array[i+1]
  //im gonna use a basic for loop/ 
  let Greatest = 0;
  
  for(let i=0; i<array.length; i++){
    let multiply = array[i] * array[i + 1];
    if(multiply > Greatest){
      Greatest = multiply;
      console.log(array, multiply)
    }
  }
  return Greatest
  }
  
  function reverseBits (n) {
   let flip = n.toString(2).split('').reverse().join('');
   let conversion = parseInt(flip, 2);
  return conversion
}


function sharedBits(a, b) {
  return a & b & (a & b) - 1 ? true : false;  //  from Python solution by Mercy Madmask
}
//I didnt realize you can just use && statments on their own for true false returns. this is interesting. 
function sharedBits(a, b) {
// so im going to convert a and b into binary
  // im going to search the binary integers. if more that two indexes match, i will
  //return true
  let bin1 = a.toString(2);
  let bin2 = b.toString(2);
  if(bin1.length < bin2.length){
  [bin1, bin2] = [bin2, bin1]
  }
  let bitCount = 0
  for(let i=0; i< bin1.length; i++){
    if(bin1[i] === '1' && bin2[i] === '1'){
      bitCount += 1
    }
  }
  return bitCount >= 2 ? true: false;
}

function correctness(bobsDecisions, expertDecisions) {
  return bobsDecisions
    .map((x,i) => x == expertDecisions[i] ? 1 : x == '?' ? 0.5 : expertDecisions[i] == '?' ? 0.5 : 0)
    .reduce((a,b)=>a+b, 0);
}

function correctness(bobsDecisions, expertDecisions) {
// so it looks like i will be comparing bobs and the experts decisions. 
  // I will need a count variable which will increase one if his and the experts opinion are
  //equal/ if they disagree, but the disagreement comes with '?' thats 0.5 points. 
  // if there they are not equal, then 0 points. 
  let count = 0;
  for(let i=0; i<bobsDecisions.length; i++){
if(bobsDecisions[i] === expertDecisions[i]){
count += 1;
}else if(bobsDecisions[i] != expertDecisions[i] && bobsDecisions[i] == '?' || expertDecisions[i] == '?' ){
  count += 0.5;
}
  }
  return count
}

function correctness(bobsDecisions, expertDecisions) {
  console.log(bobsDecisions
    .map((x,i) => x == expertDecisions[i] ? 1 : x == '?' ? 0.5 : expertDecisions[i] == '?' ? 0.5 : 0)
//     .reduce((a,b)=>a+b, 0)););
              //so map creates a new arrays with the values. if x = i that index will have a 
              // value of 1. we get those values and then we reduce
              );
}
// okay so my intuition to use map was correct. looks like i use i => x 
//if x === expertdecisions[i] 


  const stantonMeasure = (bitch) =>{
   let bitchinArray = bitch.map((x,i) => x == 1 ? 1 : 0).reduce((acc,curr)=>acc + curr)
   return bitch.map((x,i)=> x==bitchinArray ? 1 : 0).reduce((acc,curr)=>acc +curr);
  }


function stantonMeasure(arr) {
  const count = n => arr.filter(x => x === n).length;
  return count(count(1));
}
=--------------------------------------------------------------------------------------------------------------------------------------
function abbrevName(name){
return name.split(' ')[0][0].toUpperCase() + '.' + name.split(' ')[1][0].toUpperCase()

}

function pipeFix(numbers){
//input list of numbers
  let arr = [];
  for(let i=Math.min(...numbers); i<Math.max(...numbers) + 1; i++){
    arr.push(i)
  }
  return arr;
  console.log(Math.min(...numbers));
}

function countSheeps(arrayOfSheep) {
  let count = 0
  arrayOfSheep.map(x => x == true ? count += 1 : console.log());
  return count;
}
function cookingTime(eggs) {
  // 8 egg in 1 group
  //1 group takes 5 min
  // input order, output expected time
  //take order, divide it by 8, this will give me the amount of groups I have to
  // cook. round group up to the nearest whole number and then multiply by 5. 
  let groups = eggs / 8;
  
  let rounds = Math.ceil(groups);
  return rounds * 5
}

function incrementer(num) { 
  return num.map((a,i) => (a+i+1)%10);
}

function smallEnough(a, limit){
  let occurance = 0;
 a.map(x => x <= limit ? x : occurance += 1)
 return occurance > 0 ? false : true;
}

function well(x){
  let count = 0;
for(let i=0; i<x.length;i++){
if(x[i] == 'good'){
  count += 1;
}
}
  if(count <= 2 && count > 0){
    return 'Publish!'
  } else if( count > 2){
return 'I smell a series!'
  }else{
    return 'Fail!'
  }
  }


function pairZeros(arr) {
  let dbl = 0, out = [];
  
  for ( let i of arr ){
    if ( i === 0 ){
      dbl += 1;
      if ( dbl === 2 ){
        dbl = 0;
        continue
      }else{
        out.push(i);
      }
    }else{
        out.push(i);
    }
  }
  return out
}
function duplicateElements(m, n) {
  return m.some(v => n.includes(v))
}

//some is an awesome method i need to keep in my roledex. its like map in which it maps through the array, but it tests if a function/parameters are true or not

const MATCH = {
// create parameters for winning
  scissors: ['paper', 'lizard'],
  // scissors beats paper and lizard
  paper: ['rock', 'spock'],
  //paper beats rock and spock
  rock: ['lizard', 'scissors'],
  //rock beats lizard and scissors
  lizard: ['spock', 'paper'],
  //lizard beats spock and paper
  spock: ['scissors', 'rock'],
  //spock beats scissors and rock
};


function rpsls(pl1, pl2) {
//here we have our return function
//we use our MATCH array and indexOf method to determine if there is a match to pl1's answer victory matrix. if pl2 has an answer that corresponds with what is in
// the victory matrix of pl1, the indexOf method will return 1. if not it will return -1. if the returning value is 1, meaning that pl2's answer, matches with a losing value of pl1
// then pl1 wins, if the value of pl1 value likewise matches with a value in pl2 winning matrix, then pl2 wins, if the value returns is not less than or = 0, then we have a draw, meaning that the value
exists in MATCH, but not within the winning matrix
  return MATCH[pl1].indexOf(pl2) >= 0 ? 'Player 1 Won!' :
         MATCH[pl2].indexOf(pl1) >= 0 ? 'Player 2 Won!' : 'Draw!';
}
function solve(arr){
    return arr.filter((val,i) => arr.lastIndexOf(val) == i);
    // so the goal of this problem was to filter out duplicates. so we use the filter method obviously. in the filter method we are able to have two parameters, the value being passed
    // and the index number. we the use the lastIndexOf method which is the just like indexOf but reversed. the current index enters the function under the name of val, then a 'for loop'
    like process checks wheather that value exists in the array and checks if it is == to the current index. if it is equal then it gets filtered out from the new array
}

function oddOrEven(n) {
  let count = 0;
  for(let i=0; i<n;i++){
    count += i+1;
  }
  return count % 2 == 0 ? 'Even' : count == 1 || count == 0 ? 'Either' : 'Odd'
}
function add(num1, num2) {
// first im going to turn the number into a string, split, reverse, and join.
  //im going to do this so that when im adding the values in the end, it goes in order.
  // im then going to make a conditional statment that will place the longest value 
  //in the variable num1. this is for when im adding so that the correct amount of numbers get 
  //looped through in the for loop.
  //now I will create my String Container, which will hold the value of the final intger vallue
  //after that I will make my for loop. this for loop with go for the length of num1 
  //I will make int1 and int2, which will create the number values of the new reversed string. 
  // now that the numbers have been flipped and made into an integer, I can add them. 
  // I add int1[i] to int2[i] || 0 if there is not value. these are made into strings so that they are
  //not added with each other but placed next to each other.
  // now that i have the final string and the numbers have been placed next to each other, I can 
  //return with a parseInt to make it into its final value
  num1 = num1.toString().split('').reverse().join('')
  num2 = num2.toString().split('').reverse().join('')
  
  if(num1.length < num2.length){
     [num1, num2] = [num2, num1]
  }
  let returnString = ''
  for (let i=0;i<num1.length; i++){
    let int1 = parseInt(num1[i]);
    let int2 = parseInt(num2[i] || 0);
    
    returnString = (int1 + int2).toString() + returnString;
  }
  return parseInt(returnString);
}

function compare(s1, s2) {
  if (/^\D+$/gi.test(s1) && /^\D+$/gi.test(s2))
    return s1.split('').map(n => n.toUpperCase().charCodeAt()).reduce((a, b) => a + b) === 
           s2.split('').map(n => n.toUpperCase().charCodeAt()).reduce((a, b) => a + b);
  return true;
}

var FilterString = function(value) {
  console.log(value)
  let newVal = value.split('')
  console.log(newVal)
 let arr = newVal.map(x => x.charCodeAt())
 
  arr = arr.filter(x => x <= 57);
  let final = arr.map(x => x-48);
  final = final.join('')
   let theReturn = parseInt(final)
   return theReturn
}

function filterLongWords(sentence, n) {
let arr = [];
  sentence = sentence.split(' ')
  sentence.map(x => x.length > n ? arr.push(x) : console.log('bitch'));
  console.log(arr)
  return arr
}

function multiplyAndFilter(array, multiplier){
  console.log(array, multiplier)
 let arr = array.filter(x => typeof(x) === 'number')
  return arr.map(x => x * multiplier)
}

makeUnique=a=>[...new Set(a)]
function filterEvenLengthWords(words) {
  return words.filter(s=>s.length%2===0)
}
function gridMap(fn,a) {

  console.log(fn)

  // so im going to recieve a function and im ggoig to recieve an array. 

  // I want my code to take the array and map it using the given 

  //function. so the return value is the array with the function applied

  return a.map(x => x.map(fn))

// I wanted to apply a function to each array. So i map out the two arrays and in then map out the individual values which i then use to apply the function

}



stringMerge = (a, b, l) => a.slice(0, a.indexOf(l)) + b.slice(b.indexOf(l));

// so we are using the slice method. this was my first instinct honestly.

// i knew i would slicei just didnt know how to target the variabled index

// so with the syntax and the 'a' variable, we use the slice method

//to start at the zero index, which is the starting point, and we end at a.indexOf(l)

// indexOf returns the index value of the determined value. 

// so we do 0-indexOF + b.slice(start at the indexOf (the letter value))

//slice grabs the start and if the end isnt determined it grabs from start to finish. 



function inverseSlice(items, a, b) {

  console.log(items, a, b)

  let  index1 = items.slice(0, a);

  let index2 = items.slice(b)

  console.log(index1, index2)

  return index1.concat(index2)



function scrollingText(text){

  let result = []

  

  for( var i = 0; i < text.length; i++){

    result.push((text.slice(i) + text.slice(0,i)).toUpperCase())

  }

  

  return result

}



// so i had the right idea, i created a containter array

// my execution was just slightly off. I failed to use each index as the base of 

// probable combinations.   here i use text.slice(i). each index will

// change the outcome. the text doesnt change so we use 0 as the anchor

// we then use the index to rearrange what we are able to use.

// so we start from the index we currently are on. becuase we dont define 

// an end, it grabs from the i- end. we then add a slice from 0-i, which

// grabs the index values that are currently missing.



function remove(s){

  console.log(s.split('!'))

  return s.split(' ').filter(i => i.split('!').length != 2).join(' ');

  // so im going to take the string, split itby the spaces. this

  // will seperate the words into an organized array of strings.

  // im then going to filter out the array. each word will be 

  // i. the word will be split at the !, this will create a new array.

  // i the array length does not = 2, that means it passes the test and can 

  // be returned in our final result. I was thinking about how to count

  // '!' but i failed to look more abstractly. the split creates a new index

  // for every '!' which if i then use .length method, I am able to count

  // the amount of exclamation points in an array. I then join with a space for the final

  //product.

  

}



function solution(nums){

if(nums === null){

  console.log('bitch')

  return []

}else{

  console.log('bitch boi')

 return nums.sort((a,b)=> a-b)

}



function scoreTest(str, right, omit, wrong){

  console.log(str, right, omit, wrong)

  let sum = 0;

for(let i=0; i<str.length; i++){

  if(str[i] === 0){

    sum += right;

  }else if(str[i] === 1){

    sum += omit

  }else if(str[i] === 2){

    if(wrong > 0){

      sum -= wrong

    }else{

      sum += wrong

    }

  }

  

}

  return sum

}



function accum(s) {

  return s.split('').map((c, i) => (c.toUpperCase() + c.toLowerCase().repeat(i))).join('-');

  //so we start off by splitting the string. we then map it out using two parameters

  // c and i. c will act as the varable for the value of each index and i

  // will be the index value.we know we want the first index to be upper

  // case. I wasnt looking at the return the right way. i need to create

  // the solution in my code. this is an axample of that. i feel like

  // instead of that im trying to output a solution instead of creating one.

  // so i should ask myself in the future if i am able to just create

  // the solution. so i map it out. the first value is upper case so i use the 

  // toUpperCase() method. this is where i create the repeating value.

  // the repeating value has to be lower case. so i use c.toLowerCase().repeat(i) and then I join

  // the values in the array with a '-'

  

  

}

const removeConsecutiveDuplicates = s => {
  let returnarr = [];
  let array = s.split(' ')
  
  array.map(x => !returnarr.includes(x) ? returnarr.push(x) : console.log('bitch boi', returnarr))
  return returnarr
  }
  
  const removeConsecutiveDuplicates = s => s.split(" ").filter((x,i,arr) => x!=arr[i-1]).join(" ");
// so i was on the right track with this one. i even thought about the filter option. i just didnt check the third parameter, which honestly looks super useful. 
// when you use the filter method, you automatically know youre dealing with an array. the third parameter allows you to compare the tested variable with the other contents 
// of the array. so the code reads as this --> we split the string and then filter,  we use the x for each element, i for the index, and arr for the array. if x does not = arr[i - 1] 
// (i didnt realize the the filter method keeps up with x index despite it not being mentioned before, which is cool) then we want it filtered out. after the filtration process we want to join it.

function sumOfMinimums(arr) {
  return arr.map(x => Math.min(...x) ).reduce((ore, curr)=> ore+ curr)
}

function largestPairSum (numbers) {
  let find = numbers.sort((a,b)=> b-a)
  let [a,b] = [find[0], find[1]]
  let arr = [a,b]
  return arr.reduce((pre,curr)=> pre + curr)
  
}
function flattenAndSort(array) {
 
  return [].concat(...array).sort((a,b) => a-b)
}

function countDevelopers(list) {
  let count = 0;
  for(let i=0; i<list.length; i++){
    
    if(list[i].language === 'JavaScript' && list[i].continent === 'Europe'){
      count ++
    }
  }
  return count
}

function countDevelopers(list) {
  return list.filter(x=>x.continent=='Europe'&&x.language=='JavaScript').length
  // okay so They used filter to create a new array that only contained an object that passed the test of having europe and javascript. to return the number value, we used
  // length, which honestly i thought about doing but I thought it would be more complicated. I should have pursued this more because I think its creative and fun. 
}

function greetDevelopers(list) {
  list.forEach(function(developer) {
    developer.greeting = `Hi ${developer.firstName}, what do you like the most about ${developer.language}?`;
  });
  
  return list;
}
// so I use dot notation to add an element to an object in the array. I do this using the forEach method which allows me to manipulate each element in the array. 

function isRubyComing(list) {
  return list.filter(x => x.language === 'Ruby').length >= 1 ? true : false;
}
or
function isRubyComing(list) {
  return list.some(e => e.language === 'Ruby');
}
//I actually thought i did pretty well in terms of having simple/ clean code. the some method however, was exactly what I needed. the some method returns true or false
// depending on if the array contains atleast one element thar passes the test. 

this was actually my first 6 kyu. I may have done one before, but not in 7 minutes
function allContinents(list) {
 // I need to to determine if each continent is there. so this is true or false. 
  //if each continent is accounted for, true. 
  // I could create an array and if the continent isnt found in the array, i push it into the 
  // array. if the array length is 5, its a true statment. 
  let arr = [];
  list.filter(x => arr.includes(x.continent) ? console.log('its here') : arr.push(x.continent) )
  console.log(arr)
  return arr.length === 5 ? true : false
}

function isAgeDiverse(list) {
let Ages = list.map(x => x.age.toString().split('').slice(0,1))
let container = [1,2,3,4,5,6,7,8,9]
return Ages.every(x => container.includes(x)) && list.some(x => x >= 100) ? true : false
}

function isAgeDiverse(list) {
  return list.some(h => h.age >= 100) 
  ? [10,20,30,40,50,60,70,80,90].every(e => list.some(x => x.age - e >= 0 && x.age - e <= 9))
  : false;
}
// okay so i was on the right track. I basically used all teh right methods, it just wasnt ordered properly. 
// I was also trying a much harder approach honestly. 
// so in the most effecient solution, he used list.some(meaning hes checking if h is greater than or equal 100. if that is true, we create our array of parameters and use
// the every method to test if 

function getAverageAge(list) {
 // okay so i need to add all the ages up and the divid by the length
  return Math.ceil(list.map(x => x.age).reduce((curr,next) => curr + next) / list.length) 
}
function getCount(str) {
  var vowelsCount = 0;
  let vowels = ['a','e','i','o','u']
  let arr = str.split('')
  console.log(arr)
 return arr.filter(x=> vowels.includes(x)).length
}

function getMiddle(s) {
  var middle = s.length / 2;
  // create middle variable. middle is length / 2
  // glad because this is exactly how i approached it myself.
   console.log(0 ? 'hi' : 'bye')
  console.log(s.charAt(0))
  console.log(Math.floor(middle))
  // so chatAt can be used to return or deal with a value in a string
  // you can target this without having to split('') to create
  // an array of values to seperate. 
  return (s.length % 2) 
            
    ? s.charAt(Math.floor(middle))
              
              
              // here we split and round down
  // so because the returning value oof s.length % 2 === 0 
  // 0 is considered a falsy statment, so we place the even
 // value in the false place.

              
    : s.slice(middle - 1, middle + 1);
  console.log(s.slice(middle-1, middle + 1))
}


function validateWord(s, c = s.toLowerCase())
{
  return c.length % new Set(c).size == 0
  console.log(c.length % new Set(c).size == 0, c)
  // so the length of c (which is the old array but all lowercase)
  // c.length % new Set(c).size
  console.log(c.length, new Set(c), new Set(c).length)
  // the new Set(c) already creates a arrayy of only unique values, so using size
  // is kind of over kill. well its not because youre using a different menthod than length
  //
  // so new Set(c) creates a new object that holds the unique elements 
  // of the string. 
  // so we take the length, which is the total number of elements involed
  // and we divide it by the total number of unique elements. meaning
  // that if all the unique elements have a pair, we will have a remainder of 0
  // if there is only 1, itll be divinded by 1. 
  // so we create the length, we create a new object that has all the unique values
  // we we divide the two values to see if there is a remainder.
  // new Set(c) creates the object containing all the unique values
  // and size gives back a number value of how many of those objects are unique
}

function isLanguageDiverse(list) {
  list = list.map(dev => dev.language);
  const num = [...new Set(list)].map(el => list.filter(e => e === el).length);
  console.log(num, list, 'hi')
  // so we create a new set of data using the list we created and we organize
  // that data by filtering each language into its own array and measuring the length
  // of that array.
  return Math.max(...num) / Math.min(...num) <= 2
  // wee then take the max and divide it by the min. if its less than or equal to two we have 
 // true statment 
// filter and length will give you a number value of the objects/ elements that fit the criteria that you are looking for
}
// so i actually thought about using the new method as i knew
// i wuld need to create new data out of the old data
//so from start to finish we take the list and map out only the languages
// we then come up with the numbers from our data colection. 
//after we have the languages isolated, we create the num
//num is going to be a function that creates a new array with a spread
//operator. we create a new list array, which now only contained
// the lanuages we map this out and filter
// so a new object of information is created that maps and then filters the elements.
// the filters grabs the current element and then filters the list for that element
// to only grab the languages that match it. we then have an array of only the list of elements
// that match the current language. we then measure the length and that numb
