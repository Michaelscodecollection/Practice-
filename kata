

const hello = s =>
  `Hello, ${s ? (s[0].toUpperCase() + s.slice(1).toLowerCase()) : 'World'}!`;
// so here we have our one liner
// we start of by creating our function using ES6 notation. we wrap the enture return in a 
// back tick. we write our Hello. this consolidates the code since both expected returns
//  contain a greeting. the response after hello is what differs. so we use a ternary
// operator from there. we use our dollar sign and curly braces so as to allow the return 
//  statement ot be at variable to whatever is recieved. if s is accounted for, meaning it exists
//  we grab the 0 index, capitalize it with our toUpperCase method/ using dot notation
// and we slice from the 1 index onward and we lowercase it. the result would be 'hello
// Name.' if there is no name meaning their is no input accounted for, we return a simple
// 'hello world.' main methods are toUpperCase- uppercases whatever this method is set and 
// attached to. slice- which  slice() selects the elements starting at the given start argument, 
// and ends at, but does not include, the given end argument. so we sliced from the 1 index onward and used toLowerCase to 
// allow for our return to meet basic grammer requirments. 
  
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function roundIt(n){
  var [a, b] = n.toString().split('.');
  return a.length > b.length ? Math.floor(n) : a.length === b.length ? Math.round(n) : Math.ceil(n);
  return Math.Floor if n is true(true), if false test to see if a and b are equal(false but true), if true return Math.round if it is still false, return Math.ceil.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function solution(a, b) {
  return a.length < b.length ? a + b + a : b + a + b
}
// so frustatingly enough, this solution once again was way easier than I was making it out to be. here we used an effecient ternary operator. if a < b we return a + b + a : if
that is not the case, we use b + a + b. thats it. im not sure if a & b get split automatically in half. my first approach was to split the shorter one but you can only really do that with
an array and thats not what we started with, so trying to make that happen was going to over complicate it for sure,. 
function getDrinkByProfession(param) {
  param = param.toLowerCase();
  
  switch(param) {
    case "jabroni": return "Patron Tequila";
    case "school counselor": return "Anything with Alcohol";
    case "programmer": return "Hipster Craft Beer";
    case "bike gang member": return "Moonshine";
    case "politician": return  "Your tax dollars";
    case "rapper": return "Cristal";
    default: return "Beer";
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function checkExam(array1, array2) {
 // store points in variable (+=, -=)
  //we will need a for loop 
  // compare arrays. if array1[i] === array2[i] add 4
  // if array1[i] !== array2[i] subtract 1 
  // if no answer, add zero
  //if points < 0 return 0.
  //["a", "a", "b", "b"], ["a", "c", "b", "d"]
  let points = 0;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
  // here we create our for loop. now we know we are dealing with two arrays and we are comparing the both of them with one another. since we have the same length this will require
  one for loop. we will be comparing them side by side. if both answers are equal '===' we want score += 4. if the answer is incorrect we want score -= 1. if no answer is provided
  we want score += 0. 
  in our final return we want to check if score is < 0. if the final score is < 0, we will set the score = to 0 as you cannot have a negative score in this scenerio. 
  for (let i=0; i<array1.length; i++){
    if (array1[i] === array2[i]){
      points += 4;
    }else if (array2[i] === ''){
      points += 0;
    }else{
      points -= 1;
    }
  }
  return points < 0 ?  points = 0: points
  
 // if (points < 0){ 
   // points = 0;
 // }
  //return points
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
const checkExam = (array1, array2) => {
  let result = array2.reduce(
//     reduce syntac calls for (previous value, current value, current index)
//     previous value in this case is the cumulative score. answer is the current value we are
//     // measuring. i stands for the current index. these are all in respect to array2.
    //if the answer of array2(the current value) == array1[i] score(previous value increases by 4)
    // score represents the cummulative result of the reduce method so far.(previous)
//     answer represents the current value being measures/compared. 
    //i represents the index value being measured. 
    (score, answer, i) => {
      if(answer == array1[i]) return score += 4;
      else if(answer == 0) return score += 0;
      else return score - 1;
    }
  , 0);
  return result < 0 ? 0 : result;
  
  }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const greet = (name, owner) => {
return name === owner ? 'Hello boss' : 'Hello guest' 
}
// I got the equation and function right. I just need to remember to return.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')
// here we are using regex, a syntax I am completeley unfamiliar with but am excited to dive into
// we have our es6 function notation that leads to our implementation. 
// from left to right we have s(string).replace(variable to be reolaced, replacement variable)
// or in this case s.replace(/0/g,O).  here we ourline that we are targetting /0/ and that we are 
// targetting 0 globably with (g) meaning we are targetting every representation of this.
// and we want to replace this with '0'. we tak on replace after each replace because these are all an
// extention/ method to be used on the s(our string). I need to be more curious about the methods at my disposal. I need to get creative in searching for these methods
// so we have correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function paperwork(n, m) {
  return n < 0 || m < 0 ? 0 : n * m
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const century = year => Math.ceil(year/100)
// we input a 4 digit number that must return as a two digit number. we know that 
// to get the century, our year must be rounded up i.e 1700 is the 18th century.
//  so we know we are going to use a Math.ceil, this will round up whatever our output is. 
// we then divide the year by 100 to give us a two difit number. 1705 turns into 17.05, which then
// turns into 18 when the Math.ceil method is used. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//so here we are converting from american floor units to european floor units. we know that european units start at 1 whereas american united start at 0. 13 does not exist so
//starting here, we know that the difference between the two moves from 1 to 2.
//so before 13 if e < 13 we return n-1
//if greater than 13 we return n-2. but it has to start greater than 0 otherwise we get a negative number. 
//so if n < 0 (starting at 1) we use n-1. if n >= 13 we move to n-2. 

const getRealFloor = n => {
  if(n >= 13) return n - 2
  if(n > 0) return n - 1
  return n
}

or

here we use a ternary operator. if n > 13 is true, we return n-2. if it is false but n > 0 is true, we return n-1. if thats false we just return n 
function getRealFloor(n) {
  return n > 13 ? n - 2 : n > 0 ? n - 1 : n;
}
//so the way we nest ternary operators is we place the next function in the false placment and continue --> argument trueValue : falseButTry ? true : stillfalseButtry ? true : finalIfFalse. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function testEven(n) {
  return n % 2 === 0 ? true : false;
}
//I need to remember that there are all the answers I want and finding most methods are intuitive. figure out what i need to do, articulate what method that could be or terminologies that would
//fit into a method type, search. every answer I need is there and often times its less work to look for the method than it is to build code from scratch. Im wasting too much time
// trying to build codes and functions when there are methods out there that people have built to save me time. to ignore this is to hold myself back. I need to take this seriously. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function expressionMatter(a, b, c) {
//we are looking for the largest number available. we have a list of arguments that we want to pass through. at the end of the execution we want the computer to return to us
// the largets number. we use Math.max, which has the syntax Math.max(value1, value2, value3) or in other words Math.Max|imum value of|( equation1, equation2, equation3). 
//so as follows we break it down.
  return Math.max(
  // we are asking the computer to return the maxiumum value out of the following equations
    a + b + c,
    a * b * c,
    a * (b + c),
    (a + b) * c,
    a + b * c,
    a * b + c,
  );
}
when i hear something along the lines of  return the largest number, I need to think about Math.max as my first train of thought. I didnt realize I could use equations in the syntax
//looking back it makes sense this would be a fucntional use of the method. I need to remind myself that each method is more powerful and versatile than my insticnts say. im still
//over complicating things. there are simple solutions. if i had typed in return largest value, there is no doubt Math.max would have been my first option. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function squareArea(A){
  // so we are need to break this down. if we find the cirumfrence of the circle, we will
  // be able to find the diameter of the square because the diameter will be equal to the 
  // circles radius. once we find the radius we simpily pass it thorugh an equation to find the 
  // area of a square. we use Math.round to round to nearest two decimals.
  var circum = 4 * A;
  var radius = circum / (2 * Math.PI);
  var area = Math.pow(radius, 2);
  return Math.round(area*100)/100
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//class SmallestIntegerFinder {
  findSmallestInt(args) {
    // we use the spread operatir so that the computer seperates the values of the array to be 
    //compared instead of treating the whole array as a single value. we use spread
    //operators when we are dealing with array lists for that reason. 
    return Math.min(...args)
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
usdcny = $ => `${($ * 6.75).toFixed(2)} Chinese Yuan`;

//this was a super clever appraoch. I liked how they used the dollar sign as the value placeholder being inputted. I did everyhting right up until the toFixed method, which ultimatley ended
//up being a relaly cool tool once I did some research. basically it just fixes the amount of decimal places being returned. we create our input variable, use back tics to return the
//final value in a string with text. thats about it

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twiceAsOld(dadYearsOld, sonYearsOld) {
  let twiceValue = sonYearsOld * 2;
  //lets say the dad is 40 and the son is 13. the father was twice as old as the son at 26
//   so we return dads age - twice value to get the years ago. if we go in the negative then we know
  //that we have to add years, so we instead return twiceValue-dadYearsOld to get the amount of years until
  return dadYearsOld - twiceValue >= 0 ? dadYearsOld - twiceValue : twiceValue - dadYearsOld;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function updateLight(current) {
  
  return current === 'yellow' ? 'red' : current === 'green' ? 'yellow' : 'green';

}

const reverseSeq = n => {
let arr = [];
  for (let i=n; i>0; i--) {
  //we start at n and we work our way down after each iteration. 
    arr.push(i);
    } return arr;
};

// so here I did everything right except for the syntax of my for loop. I wasnt thinking. I need to look at each individual mechanism im coding. Im not paying attention. 
// so in this case I actually tried to make it simpiler than it was. although im pleased i searched for a possible solution, the switch case was an obvious solution that I should have
// approached and then refactored. I think what I need to do is approach the longer versions and THEN refactor instead of just trying to refactor. 
// if im dealing with values and a string like this i need to think of more creative solutions. I need to ask myself what do my available resources fit into
function basicOp(operation, value1, value2) {
    switch (operation) {
        case '+':
            return value1 + value2;
        case '-':
            return value1 - value2;
        case '*':
            return value1 * value2;
        case '/':
            return value1 / value2;
        default:
            return 0;
    }
}

function digitize(n) {
  return String(n).split('').map(Number).reverse()
}

// so my first inclenation was to split and reverse. while that was correct, I forgot one thing. you cant split integers. I need to convert to a string, split, map out that string as Numbers,THEN 
//I reverse it. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
var summation = function (num) {
  let result = 0;
  for (var i = 1; i <= num; i++) {
  //we start i at 1 because it is only being returned as a positive number and we are only including numbers <= 1. we then make i<=num so that num is included in the final addition. 
  
    result += i;
  }
  
  return result;
}
// I had all the right instincts. I did two things wrong. I didnt set the function right which may have been why I kept getting 0/ NAN, I set I to 0 and num. I knew that it was going to be 
// a different type of for loop, and I was paying attention to that this time, which is encouraging. And I made i < num instead of <= num, which makes sense because we wanted to
//include the last number in the addition too. I also kept trying to return num[i] which isnt the value of the index im targeting, its the index number. If i want the value of whatever
iteration im on, i simp[ily need to type i
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function numberToString(num) {
  return num.toString()
}
 
 function boolToWord( bool ){
 return bool ? 'Yes' : 'No';
}

const opposite=(number)=> {
  return number < 0 ? Math.abs(number) : -number;
}

function even_or_odd(number) {
  return number % 2 === 0 ? 'Even' : 'Odd';
}
const otherAngle = (a, b) => {
  // All angles of a traingle will add up to 180. 
  // return 180 - (a + b)
  
  return 180 - (a+b);
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const doubleChar = (str) => str.split("").map(c => c + c).join("");
//so we want to repeat a string. my first instinct of split and join were correct, I was just missing how to connect the two in this context. so we split, which turns it into an array
// beause its an array and we are able to use the map method to make copies of what we already have available. we basically say that we want to take c => and make two c's. 
//once we that function executes and we have two of every iteration (naturally dont by the map method) we then join it('') with no space in the middle.

const digitize = (n) => { return String(n).split('').map(Number).reverse() }
//so in this case i didnt realize that the split method only works with strings. so before i can split i have to make it a string with the String method. cool. once
// I its a String and split, I map out what was split with maps argument (the parameters given to the computer to determine how to map out the data) being the Number method, which will 
//turn the string into numbers. now that we have our numbers split up in an array, we use the reverse method to flip and we return the final product.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
  return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
  // so here we are using a spread operator and new operator to create a new array which will be set using the inputted arr that will only return unique elements. that is only one
  //of each instead of all of them. if there are 2,2,2,5,5,9,2,10 the new array will return as 2,5,9,10. we the sort the new array with a function(a,b)=>b-a returning the largest numbers
  //first using basic sorting syntax. we then slice from 0,2 (the first and second items) and return.
}
// while i didnt get this one, im super stoked because i basically touched on every element the solution had, which is encouraging to say the least. I played with sort, slice, created a a,b equation
.i neew to figure out what ...new and Set is. Im assuming ...new creates a new array
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
var stringToNumber = function(str){
  // put your code here
  return Number(str);
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function abbrevName(name){
let nameArr = name.split(' ')
return (nameArr[0][0] + '.' + nameArr[1][0]).toUpperCase();
}

function twoHighest(arr) {
  return [...new Set(arr)].sort((a,b)=> b-a).slice(0,2)
}
// function twoHighest(arr) {
//   return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
// }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const trueFalse = (b) => return b ? 'true' : 'false'
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function invert(array) {
  var newArr = [];
  for(var i = 0; i < array.length; i++){
    newArr.push(-array[i]);
  }
   return newArr;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const positiveSum =(arr)=>{
  let count=0
  for (let i=0; i< arr.length; i++){
    if(arr[i] > 0)
      count += arr[i];
  }
  return count;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function positiveSum (arr) {
  return arr.filter(x => x>=0).reduce((a, c) => a + c, 0);
}


const positiveSum =(arr)=>{
 return arr.reduce((cumm,curr)=>cumm + (curr > 0 ? curr : 0),0);
//   with a reduce funtion, if we want to get the sum of an array, we need to clarify to
  //computer that we want it to start at the zero index because without an initial value
  //provided, it starts at the 1 index.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function enough(cap, on, wait) {
 return wait <= (cap -on) ? 0 : Math.abs((cap-on)-wait)
  
  
}
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function sumStr(a,b) {
  let summ = Number(a) + Number(b) 
  return String(summ)
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function isDivisible(n, x, y) {
  return n % x === 0 && n % y === 0 ? true : false;
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function remainder(a, b){
  return a > b ? a % b : b % a
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function enough(cap, on, wait) {
 return wait <= (cap -on) ? 0 : Math.abs((cap-on)-wait)
  
  
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

class Kata {
  static getVolumeOfCuboid(length, width, height) {
    return length * width * height
  }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function betterThanAverage(classPoints, yourPoints) {
  return yourPoints > (classPoints.reduce((a,b)=>a+b)/classPoints.length) ? true : false;
}

function switchItUp(number){
  switch(number) {
    case 0:
      return 'Zero';
    case 1:
      return 'One';
    case 2:
      return 'Two';
    case 3:
      return 'Three';
    case 4:
      return  'Four';
    case 5:
      return 'Five';
    case 6:
      return 'Six';
    case 7:
      return 'Seven';
    case 8:
      return 'Eight';
    case 9:
      return 'Nine';
    default:
      return 'Unknown number';
  }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function invert(array) {
   return array.map( x => x === 0 ? x : -x);
}

//okay, so I had the right assumption of mapping but i didnt follow that hunch. mapping seems to be a function I need to get more comfortable using. I need to remember that mapping is such
// a great tool for whenever I want to use for loop functionality while also applying a function into the contents. Here We return a mapped array with rach iteration (x) going through
// a function that tests if x === 0. if x does not deeply equal 0

function areYouPlayingBanjo(name) {
 return name[0] === 'R' || name[0] === 'r' ? `${name} plays banjo` : `${name} does not play banjo`

}
function maps(x){
return x.map(x => x * 2)
}
const zeroFuel = (distanceToPump, mpg, fuelLeft) => {
  return distanceToPump - (fuelLeft * mpg) <= 0 ? true : false
};

const areaOrPerimeter = function(l , w) {
  return l === w ? l * w : 2 * (l+w);
};

  //so I tried  to use a spread operator which may have worked but was a lot more complicated.
  // I was on the right track with everything else but had a couple syntax issues.
  // here we split the array, sort, target the -1 index which is the last characted in each
  //individual string and we create our function for sorting with a > b. I didnt realize this 
  //before but when sorting by numbers we use the equation (a -/+ b) but when we sort letters we
  //have to use (a >/< b). so again I was on the right track. I tried targeting the index 
  //but again, that wasnt going to work the way that I had hoped. instead I should have used
  //a.slice(-1) which would target the end/ final character in each iteration.
  const last = ( $ ) => $.split(' ').sort((a,b)=> a.slice(-1) > b.slice(-1))
}


const numbers = (...arr) => arr.every(x => typeof x === 'number')

//so here we say that whatever arr is will be spread as it passes into the function. 
// we then attach a every method to arr to check if every iteration of the arr matches.
// in every() we pass a function that will check if the typeof x is = to number. 
//every has a call back that will naturally return true or false.

discovered a cool method called every(which checks if iteration of a delivered array matches a the parameter defined by a function in the callback)


function square(n){
return Math.pow(2, n-1)
//so we basically just want to pass through the returned value of the inputted number - 1 
  //and them doubled.
}

function spongeMeme(sentence) {
return sentence.split('').map((v,i) => i % 2 ? v.toLowerCase(): v.toUpperCase()).join('');
} 
//super stoked. even though i didnt get it and ignored by gut, my hunch was completeley correct. Im growing the intuition. Here we split the sentence. because we want to deal with each
//iteration (which basically means we need a for loop) we use a map and pass a function in map to tell the computer how we want to treat each iteration (DANK!). we then pass through our parameters.
//which is a function. I forgot the syntax for map. we have v,i . v standing for the current element and i so that we can target the elements index. we target the index with i % 2 === 0
// if true we manipulate the element. so were dealing with the element AND the index. luckily for us map has it built in to distinguish the two. I have to remember that moving forward because I
//almost had it. 

// ficing code const findLongest = (str)=>{
  
  var spl = str.split(" ");
  var longest = 0
  
  for (var i = 0; i < spl.length; i++){
    if (spl[i].length > longest) {
      longest = spl[i].length
    }
    }
    return longest
}

function gooseFilter (birds) {
  var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
  return birds.filter(b => !geese.includes(b));
};

okay so on this one, I actually had the logic right but i mixed up the syntax. in my return i did return birds.filter(bird => bird.includes(...geese)), looking back, I realize
// this makes sense btecause i used the input, and then searched the the input to see if it would include the geese array. !gees.includes(b) is really asking the computer
// if the array geese includes b. if it does not, meaning we get a return value of true, we filter it out. i also wasnt paying attention to what the problem was really asking. 
I thought the point was to only keep the defined birds when in reality I was supposed to filter our the defined birds. Im happy because my logic was almost correct in that case.
// just to be clear, the filter method creates a new array filled with true values and removes false values. the includes method is a true/false method. which is exactly what we needed
//for the filter. this is also why we had to use a ! because we were only wanting to keep the values !included in our geese array.
//if b is not included in geese, then we keep the value.

function hoopCount (n) {
return n >= 10 ? "Great, now move on to tricks" : "Keep at it until you get it"
}

function findDifference(a, b) {
let A = a.reduce((acc,curr)=>acc * curr);
let B = b.reduce((acc,curr)=> acc * curr);
  return A - B >= 0 ? A-B : B-A;
}

function DNAtoRNA(dna){
  return dna.replace(/T/g, 'U');
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function find_average(array) {
  var sum = array.reduce((a, b) => a + b, 0);
  return sum/array.length;
}
we want to return 0 if the array is empty, so we start at the 0 index and we do a + b. If its 0 our last return will be 0 / 0 so we are successful


-----------------------------------------------------------------reviewing past katas now-------------------------------------------------------------------------------
const maps=(x)=>{
return x.map(x=>x * 2)
}
const areYouPlayingBanjo = (name) => {
  return name[0] === 'r' || name[0] === 'R' ? `${name} plays banjo` : `${name} does not play banjo`;
}
const numbers = (...arr) => arr.every(x => typeof x === 'number')
this one i actually almosty got perfectly but i forgot about the every method. stoaked because last time i didnt even get close

const areaOrPerimeter = function(l , w) {
 return l === w ? l * w : 2 * (l + w)
};

const animal=(obj)=>{
  return `This ${obj.color} ${obj.name} has ${obj.legs} legs.`
}

function countPositivesSumNegatives(input) {
  //so here i really like this code because it basically follows verbatim the instructions.
  //its objective based code. 
    if (input == null || input.length == 0)
      return [];
    // we begin with our basic parameters. if the input is null or the length of input is 0
  // we return an empty array.
    var positive = 0;
    var negative = 0;
    // we know we are looking for a count, so we create our count storage for positive and negative numbers
  
    for (var i=0, l=input.length; i<l; ++i)
    {
      if (input[i] > 0)
        ++ positive;
        //I also was not paying attention to the instructions. I keep doing this. I need to focus on what is being asked of me, I need to get back into the habit of pseudo coding
        // im working with fundamentals and so I think im tough shit because of all of these one liners. Im not. Just because I know what to do and am excited doesnt mean i shouldnt take the time to processs what is 
        //in front of me. 
      else
        negative += input[i];
    }
  //we use a basic for loop to organize which index will be sorted to which sum. 
    
    return [positive, negative];
  // we place our counted values into an array and we return. 

//okay i need to get better at deconstructing. im trying to be fancy and its not smart. I could have solved this one if i wasnt always trying to do one liners. I need to be more
// aware of the fact that i need to learn to write good code. not impressive code. clean code. 
function calculator(a,b,sign){
 if ((typeof a == 'number') && (typeof b == 'number')){
   switch(sign){
       case '*':
       return a * b;
       break;
       case '+':
       return a + b;
       break;
       case '/':
       return a / b;
       break;
       case '-':
       return a - b;
       break;
   }
  
 }
 return 'unknown value'
}
// I need to slow down and think of all the tactics i can approach problems with. I once again, thought i could just type out what was in my head and totally over complicated the code.
switch statment would have been such an easy approach. at this point im being lazy and i know it. I need to be intentional, focued, and give the problem the respect it deserves.
coding requires attention and focus. I cant just superfically think my way through this career. 

function between(a, b) {
  //  we want to input 1 and 4 and get a returned value of 1,2,3,4.
  //how can i go about doing this? 
  //i can use a for loop. start i at 8, and make the iteration go until it is <= b.
  // 
  let arr = [];
  for(let i=a; i <= b; i++){
    arr.push(i)
  }
    return arr;
  
}
function getAge(inputString){
return parseInt(inputString)
}

function pipeFix(numbers){
  var first = numbers[0];
  var last = numbers[numbers.length-1];
  // so here we create our first (starting point) and out last (ending point)
  // we use the 0 index to locate our starting value and the -1 index to input our ending value.
  var arr = [];
  // we create an array to harness our final result
  for(var i = first; i <= last; i++) {
  // we then use our first and last values in a for loop and we increment through. we push the output of the for loop into our new array.
    arr.push(i);
  }
  return arr;
}
//so we create our starting and ending point. then we just for loop from start to finish. I tried creating and replacing all the values which was way more work. I need to spend more time thinking 
about what i need to do. Maybe i should start a timer. take one minute to not code at all and just think of my various approaches instead of just jumping on the first thing that makes sense. 

function cost (mins) { 
  return 30 + ( mins>65 ?  Math.ceil((mins-65)/30) : 0 )*10
  // return 30 + if minutes is greater than 65 min ($30 for the first hour + 5 min grace period)
  // then we do round up using Math.ceil. we do mins - 65/30. that number gets multiplied by 10
  // and then is added to the total cost. I need to be better about picking out details like round
  //up.
  
  function perimeterSequence(a,n) {
  return a * n * 4
 //over complicated it again. I need to slow down. I need to break down the problem even smaller then I am. there arent big chunks that im forgetting. 
}

//today is my first day moving onto 7 kyu and its been an adjustment 
first off, I have to get used to the fact the code is going to be much longer moving forward. no more one liners. so when writing out the code, I have to really set up the playing
//field im going to be working with. no more one liners. I need to write everything out and create all the variables im going to be working with. I also have to embrace the mantra
of ' the first step to knowing is not knowing. ' 
the last couple katas i did i made things a little more complicated than i needed too. I need to simplify but its not just that. I tried simplifying but my ignorance with different fundamentals
of algebra is effecting my ability to problem solve. I need to make an investment in my understanding of algebra. 
that being said, its time to break down the first big problem
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function add(num1, num2) {
// so here we get our two numbers. now first thing i need to note is that one of the things we need to check for is for which numbver is greater, because if theres two numbers for 
// one and theres three numbers for another, its gonna effect which number is being added to which number.

    num1 = num1.toString().split("").reverse().join("");
    num2 = num2.toString().split("").reverse().join("");
    //so here we create our variables num1 and num2 exceot we create them in the context of solving the problem.
    // we know that we need to turn the numbers into a string, split the number, reverse it, and join it back. this turns 200 into '002' and 60 into '06'

 

    if (num1.length < num2.length) {
        [num1, num2] = [num2, num1];
    }
// here we check for if num1.length is less than num2.length. 
in the case that num1 is less than num2, our [num1,num2] array will instead be [num2,num1].
 

    var returnString = "";
    here we have our returning value which is going to be a string at first.
    
    for (var i = 0; i < num1.length; i++) {
    // since we made the largest value num1, we are going to use a for loop to loop through these values. this is why we made our number a string.
    
        var int1 = parseInt(num1[i]);
      // now we are going to turn our string into a number. int1 is going to be representing num1 iterations and int2 will be representing num2 iterations. 
      
        var int2 = parseInt(num2[i] || 0);
      
        returnString = (int1+ int2).toString()+returnString;
        // now that we have the two integers defined as to being which ever num[i] we are on, we can loop through.
        // we have int1 + int 2 turned into a string and placed next to which ever value was last created. 
        so if we have 268 + 318 --> '862' + '813' --> 
        8 + 8 === 16 --> returnString == '16'
        6 + 1 === 7 --> returnString =='716'
        3 + 2 === 5 --> returnString == '5716'
        
    }
    
    return parseInt(returnString);
    //here we turn our '5716' into 5716 (String to Integer)
}
// my main mistake was not breaking it down more. I can make my life a lot more simple if I take the time to make create a map to my destination. 

function arrowArea(a,b) {
  // A = bh/2
  //b = a
  //h = b/2
  let base = a;
  let h = b/2;
  return (base * h)/ 2
}
// followed my own advise for an A1 result

// we want to scan the string given to us.
  //we are looking specifically for 'n'
  //if 'n' count <= 15 return 'Woohoo' else return 'Car Dead'
  //I can use a count variable. if x[i] == n count += 1. if count = 16 return car dead
  let count = 0
  for (let i=0; i < x.length; i++){
    if (x[i] === 'n'){
      count += 1;
    }
    
  }
  return count > 15 ? 'Car Dead':'Woohoo!'
}

//really slowed myself down and let go of the pressure to solve it and wow it was so much easier. My mentality has been all wrong. I need to break it down, get curious, get analytical,
and just take it piece by piece. Its not one big problem that needs to be solved. Its a bunch of little ones. I should get better with using console.log()


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function automorphic(n){
  let len = n.toString().length
  //here we create out number and measure its length. this value will be used to grab the particular index we want
  let num = (n * n).toString().slice(-len)
  we then create our squared value, turn it into a string and we slice the index using a negative number (which starts from the end of the array and will go until the value
  len is achieved.
  return (n == num) ? 'Automorphic' : 'Not!!'
  //we then use a double equal sign to check if the values are the same (although not deeply same since num is a string and n is a integer. 
}

function balancedNum(number) {
  let numstr = number.toString();
  let leftside = "";
  let rightside = "";
  if (numstr.length/2 < 1 || numstr.length === 2) { 
    return "Balanced";
  }
  
  function createArrayOfTiers(num) {
    let prev = '';
    return [...num + ''].map((value) => {
        return prev += value;
    });
}
  if (numstr.length % 2 === 0) {
    leftside = numstr.slice(0,numstr.length/2-1);
  } else {
    leftside = numstr.slice(0,numstr.length/2);
  }
  rightside = numstr.slice(numstr.length/2+1);
  
  let lefttotal = leftside.split("").reduce((a,b)=>parseInt(a)+parseInt(b));
  let righttotal = rightside.split("").reduce((a,b)=>parseInt(a)+parseInt(b));
  return (lefttotal === righttotal) ? "Balanced" : "Not Balanced";
}
