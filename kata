

const hello = s =>
  `Hello, ${s ? (s[0].toUpperCase() + s.slice(1).toLowerCase()) : 'World'}!`;
// so here we have our one liner
// we start of by creating our function using ES6 notation. we wrap the enture return in a 
// back tick. we write our Hello. this consolidates the code since both expected returns
//  contain a greeting. the response after hello is what differs. so we use a ternary
// operator from there. we use our dollar sign and curly braces so as to allow the return 
//  statement ot be at variable to whatever is recieved. if s is accounted for, meaning it exists
//  we grab the 0 index, capitalize it with our toUpperCase method/ using dot notation
// and we slice from the 1 index onward and we lowercase it. the result would be 'hello
// Name.' if there is no name meaning their is no input accounted for, we return a simple
// 'hello world.' main methods are toUpperCase- uppercases whatever this method is set and 
// attached to. slice- which  slice() selects the elements starting at the given start argument, 
// and ends at, but does not include, the given end argument. so we sliced from the 1 index onward and used toLowerCase to 
// allow for our return to meet basic grammer requirments. 
  
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function roundIt(n){
  var [a, b] = n.toString().split('.');
  return a.length > b.length ? Math.floor(n) : a.length === b.length ? Math.round(n) : Math.ceil(n);
  return Math.Floor if n is true(true), if false test to see if a and b are equal(false but true), if true return Math.round if it is still false, return Math.ceil.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function solution(a, b) {
  return a.length < b.length ? a + b + a : b + a + b
}
// so frustatingly enough, this solution once again was way easier than I was making it out to be. here we used an effecient ternary operator. if a < b we return a + b + a : if
that is not the case, we use b + a + b. thats it. im not sure if a & b get split automatically in half. my first approach was to split the shorter one but you can only really do that with
an array and thats not what we started with, so trying to make that happen was going to over complicate it for sure,. 
function getDrinkByProfession(param) {
  param = param.toLowerCase();
  
  switch(param) {
    case "jabroni": return "Patron Tequila";
    case "school counselor": return "Anything with Alcohol";
    case "programmer": return "Hipster Craft Beer";
    case "bike gang member": return "Moonshine";
    case "politician": return  "Your tax dollars";
    case "rapper": return "Cristal";
    default: return "Beer";
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function checkExam(array1, array2) {
 // store points in variable (+=, -=)
  //we will need a for loop 
  // compare arrays. if array1[i] === array2[i] add 4
  // if array1[i] !== array2[i] subtract 1 
  // if no answer, add zero
  //if points < 0 return 0.
  //["a", "a", "b", "b"], ["a", "c", "b", "d"]
  let points = 0;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
  // here we create our for loop. now we know we are dealing with two arrays and we are comparing the both of them with one another. since we have the same length this will require
  one for loop. we will be comparing them side by side. if both answers are equal '===' we want score += 4. if the answer is incorrect we want score -= 1. if no answer is provided
  we want score += 0. 
  in our final return we want to check if score is < 0. if the final score is < 0, we will set the score = to 0 as you cannot have a negative score in this scenerio. 
  for (let i=0; i<array1.length; i++){
    if (array1[i] === array2[i]){
      points += 4;
    }else if (array2[i] === ''){
      points += 0;
    }else{
      points -= 1;
    }
  }
  return points < 0 ?  points = 0: points
  
 // if (points < 0){ 
   // points = 0;
 // }
  //return points
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
const checkExam = (array1, array2) => {
  let result = array2.reduce(
//     reduce syntac calls for (previous value, current value, current index)
//     previous value in this case is the cumulative score. answer is the current value we are
//     // measuring. i stands for the current index. these are all in respect to array2.
    //if the answer of array2(the current value) == array1[i] score(previous value increases by 4)
    // score represents the cummulative result of the reduce method so far.(previous)
//     answer represents the current value being measures/compared. 
    //i represents the index value being measured. 
    (score, answer, i) => {
      if(answer == array1[i]) return score += 4;
      else if(answer == 0) return score += 0;
      else return score - 1;
    }
  , 0);
  return result < 0 ? 0 : result;
  
  }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const greet = (name, owner) => {
return name === owner ? 'Hello boss' : 'Hello guest' 
}
// I got the equation and function right. I just need to remember to return.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')
// here we are using regex, a syntax I am completeley unfamiliar with but am excited to dive into
// we have our es6 function notation that leads to our implementation. 
// from left to right we have s(string).replace(variable to be reolaced, replacement variable)
// or in this case s.replace(/0/g,O).  here we ourline that we are targetting /0/ and that we are 
// targetting 0 globably with (g) meaning we are targetting every representation of this.
// and we want to replace this with '0'. we tak on replace after each replace because these are all an
// extention/ method to be used on the s(our string). I need to be more curious about the methods at my disposal. I need to get creative in searching for these methods
// so we have correct = s => s.replace(/0/g,'O').replace(/1/g,'I').replace(/5/g,'S')

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function paperwork(n, m) {
  return n < 0 || m < 0 ? 0 : n * m
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const century = year => Math.ceil(year/100)
// we input a 4 digit number that must return as a two digit number. we know that 
// to get the century, our year must be rounded up i.e 1700 is the 18th century.
//  so we know we are going to use a Math.ceil, this will round up whatever our output is. 
// we then divide the year by 100 to give us a two difit number. 1705 turns into 17.05, which then
// turns into 18 when the Math.ceil method is used. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//so here we are converting from american floor units to european floor units. we know that european units start at 1 whereas american united start at 0. 13 does not exist so
//starting here, we know that the difference between the two moves from 1 to 2.
//so before 13 if e < 13 we return n-1
//if greater than 13 we return n-2. but it has to start greater than 0 otherwise we get a negative number. 
//so if n < 0 (starting at 1) we use n-1. if n >= 13 we move to n-2. 

const getRealFloor = n => {
  if(n >= 13) return n - 2
  if(n > 0) return n - 1
  return n
}

or

here we use a ternary operator. if n > 13 is true, we return n-2. if it is false but n > 0 is true, we return n-1. if thats false we just return n 
function getRealFloor(n) {
  return n > 13 ? n - 2 : n > 0 ? n - 1 : n;
}
//so the way we nest ternary operators is we place the next function in the false placment and continue --> argument trueValue : falseButTry ? true : stillfalseButtry ? true : finalIfFalse. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function testEven(n) {
  return n % 2 === 0 ? true : false;
}
//I need to remember that there are all the answers I want and finding most methods are intuitive. figure out what i need to do, articulate what method that could be or terminologies that would
//fit into a method type, search. every answer I need is there and often times its less work to look for the method than it is to build code from scratch. Im wasting too much time
// trying to build codes and functions when there are methods out there that people have built to save me time. to ignore this is to hold myself back. I need to take this seriously. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function expressionMatter(a, b, c) {
//we are looking for the largest number available. we have a list of arguments that we want to pass through. at the end of the execution we want the computer to return to us
// the largets number. we use Math.max, which has the syntax Math.max(value1, value2, value3) or in other words Math.Max|imum value of|( equation1, equation2, equation3). 
//so as follows we break it down.
  return Math.max(
  // we are asking the computer to return the maxiumum value out of the following equations
    a + b + c,
    a * b * c,
    a * (b + c),
    (a + b) * c,
    a + b * c,
    a * b + c,
  );
}
when i hear something along the lines of  return the largest number, I need to think about Math.max as my first train of thought. I didnt realize I could use equations in the syntax
//looking back it makes sense this would be a fucntional use of the method. I need to remind myself that each method is more powerful and versatile than my insticnts say. im still
//over complicating things. there are simple solutions. if i had typed in return largest value, there is no doubt Math.max would have been my first option. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function squareArea(A){
  // so we are need to break this down. if we find the cirumfrence of the circle, we will
  // be able to find the diameter of the square because the diameter will be equal to the 
  // circles radius. once we find the radius we simpily pass it thorugh an equation to find the 
  // area of a square. we use Math.round to round to nearest two decimals.
  var circum = 4 * A;
  var radius = circum / (2 * Math.PI);
  var area = Math.pow(radius, 2);
  return Math.round(area*100)/100
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//class SmallestIntegerFinder {
  findSmallestInt(args) {
    // we use the spread operatir so that the computer seperates the values of the array to be 
    //compared instead of treating the whole array as a single value. we use spread
    //operators when we are dealing with array lists for that reason. 
    return Math.min(...args)
  }
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
usdcny = $ => `${($ * 6.75).toFixed(2)} Chinese Yuan`;

//this was a super clever appraoch. I liked how they used the dollar sign as the value placeholder being inputted. I did everyhting right up until the toFixed method, which ultimatley ended
//up being a relaly cool tool once I did some research. basically it just fixes the amount of decimal places being returned. we create our input variable, use back tics to return the
//final value in a string with text. thats about it

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twiceAsOld(dadYearsOld, sonYearsOld) {
  let twiceValue = sonYearsOld * 2;
  //lets say the dad is 40 and the son is 13. the father was twice as old as the son at 26
//   so we return dads age - twice value to get the years ago. if we go in the negative then we know
  //that we have to add years, so we instead return twiceValue-dadYearsOld to get the amount of years until
  return dadYearsOld - twiceValue >= 0 ? dadYearsOld - twiceValue : twiceValue - dadYearsOld;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function updateLight(current) {
  
  return current === 'yellow' ? 'red' : current === 'green' ? 'yellow' : 'green';

}

const reverseSeq = n => {
let arr = [];
  for (let i=n; i>0; i--) {
  //we start at n and we work our way down after each iteration. 
    arr.push(i);
    } return arr;
};

// so here I did everything right except for the syntax of my for loop. I wasnt thinking. I need to look at each individual mechanism im coding. Im not paying attention. 
// so in this case I actually tried to make it simpiler than it was. although im pleased i searched for a possible solution, the switch case was an obvious solution that I should have
// approached and then refactored. I think what I need to do is approach the longer versions and THEN refactor instead of just trying to refactor. 
// if im dealing with values and a string like this i need to think of more creative solutions. I need to ask myself what do my available resources fit into
function basicOp(operation, value1, value2) {
    switch (operation) {
        case '+':
            return value1 + value2;
        case '-':
            return value1 - value2;
        case '*':
            return value1 * value2;
        case '/':
            return value1 / value2;
        default:
            return 0;
    }
}

function digitize(n) {
  return String(n).split('').map(Number).reverse()
}

// so my first inclenation was to split and reverse. while that was correct, I forgot one thing. you cant split integers. I need to convert to a string, split, map out that string as Numbers,THEN 
//I reverse it. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
var summation = function (num) {
  let result = 0;
  for (var i = 1; i <= num; i++) {
  //we start i at 1 because it is only being returned as a positive number and we are only including numbers <= 1. we then make i<=num so that num is included in the final addition. 
  
    result += i;
  }
  
  return result;
}
// I had all the right instincts. I did two things wrong. I didnt set the function right which may have been why I kept getting 0/ NAN, I set I to 0 and num. I knew that it was going to be 
// a different type of for loop, and I was paying attention to that this time, which is encouraging. And I made i < num instead of <= num, which makes sense because we wanted to
//include the last number in the addition too. I also kept trying to return num[i] which isnt the value of the index im targeting, its the index number. If i want the value of whatever
iteration im on, i simp[ily need to type i
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function numberToString(num) {
  return num.toString()
}
 
 function boolToWord( bool ){
 return bool ? 'Yes' : 'No';
}

const opposite=(number)=> {
  return number < 0 ? Math.abs(number) : -number;
}

function even_or_odd(number) {
  return number % 2 === 0 ? 'Even' : 'Odd';
}
const otherAngle = (a, b) => {
  // All angles of a traingle will add up to 180. 
  // return 180 - (a + b)
  
  return 180 - (a+b);
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const doubleChar = (str) => str.split("").map(c => c + c).join("");
//so we want to repeat a string. my first instinct of split and join were correct, I was just missing how to connect the two in this context. so we split, which turns it into an array
// beause its an array and we are able to use the map method to make copies of what we already have available. we basically say that we want to take c => and make two c's. 
//once we that function executes and we have two of every iteration (naturally dont by the map method) we then join it('') with no space in the middle.

const digitize = (n) => { return String(n).split('').map(Number).reverse() }
//so in this case i didnt realize that the split method only works with strings. so before i can split i have to make it a string with the String method. cool. once
// I its a String and split, I map out what was split with maps argument (the parameters given to the computer to determine how to map out the data) being the Number method, which will 
//turn the string into numbers. now that we have our numbers split up in an array, we use the reverse method to flip and we return the final product.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
  return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
  // so here we are using a spread operator and new operator to create a new array which will be set using the inputted arr that will only return unique elements. that is only one
  //of each instead of all of them. if there are 2,2,2,5,5,9,2,10 the new array will return as 2,5,9,10. we the sort the new array with a function(a,b)=>b-a returning the largest numbers
  //first using basic sorting syntax. we then slice from 0,2 (the first and second items) and return.
}
// while i didnt get this one, im super stoked because i basically touched on every element the solution had, which is encouraging to say the least. I played with sort, slice, created a a,b equation
.i neew to figure out what ...new and Set is. Im assuming ...new creates a new array
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function twoHighest(arr) {
var stringToNumber = function(str){
  // put your code here
  return Number(str);
}
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function abbrevName(name){
let nameArr = name.split(' ')
return (nameArr[0][0] + '.' + nameArr[1][0]).toUpperCase();
}

function twoHighest(arr) {
  return [...new Set(arr)].sort((a,b)=> b-a).slice(0,2)
}
// function twoHighest(arr) {
//   return [...new Set(arr)].sort((a, b) => b - a).slice(0, 2)
// }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const trueFalse = (b) => return b ? 'true' : 'false'
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function invert(array) {
  var newArr = [];
  for(var i = 0; i < array.length; i++){
    newArr.push(-array[i]);
  }
   return newArr;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const positiveSum =(arr)=>{
  let count=0
  for (let i=0; i< arr.length; i++){
    if(arr[i] > 0)
      count += arr[i];
  }
  return count;
}
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function positiveSum (arr) {
  return arr.filter(x => x>=0).reduce((a, c) => a + c, 0);
}


const positiveSum =(arr)=>{
 return arr.reduce((cumm,curr)=>cumm + (curr > 0 ? curr : 0),0);
//   with a reduce funtion, if we want to get the sum of an array, we need to clarify to
  //computer that we want it to start at the zero index because without an initial value
  //provided, it starts at the 1 index.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function enough(cap, on, wait) {
 return wait <= (cap -on) ? 0 : Math.abs((cap-on)-wait)
  
  
}
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  function sumStr(a,b) {
  let summ = Number(a) + Number(b) 
  return String(summ)
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

function isDivisible(n, x, y) {
  return n % x === 0 && n % y === 0 ? true : false;
}
